# Syntax and Style Guide

*Comp language syntax rules, style conventions, and formatting guidelines*

## Style Guide

The standard style uses:

- Tabs for indentation
- Tokens prefer kebab-case (lowercase with hyphens)
- Prefer boolean function and fields with a trailing `?`
- Operators at the start (`|`) when splitting long lines
- Lines under 100 characters when reasonable
- Function references always attached: `|function` not `| function`
- Undecorated tokens for field access in pipelines

## Whitespace

Whitespace is completely optional in most places of the language. Whitespace
can consist of any amount of spaces, tabs, extra lines or indentation.

The only place whitespace is required is between fields of a structure
and between the operations a function or structure.

```comp
@primes = {1 3
 5      7}

!func |tight = {"oneline"}
!func 
 |spacey
={
                @first = 
    1 @second=2
}
```

## Operator Reference

**Mathematical operators:**
- `+`, `-`, `*`, `/`, `%` - Arithmetic operations  
- `+-` - Explicit subtraction (disambiguates from kebab-case identifiers)
- `**` - Power/exponentiation
- `==`, `!=` - Equality comparison
- `<`, `<=`, `>`, `>=` - Ordering comparison

**Logical operators (symmetric double-character design):**
- `&&` - Logical AND (short-circuiting)
- `||` - Logical OR (short-circuiting)  
- `!!` - Logical NOT (boolean negation)
- Note: All logical operators use double characters for consistency and clarity

**Pipeline and function operators:**
- `()` - Pipeline boundaries  
- `|` - Function application
- `|?` - Failure handling
- `|<<` - Pipeline modifier (wrench operator)
- `.{}` - Block delimiter

**Assignment operators:**
- `=` - Normal assignment
- `*=` - Strong assignment (resists overwriting)  
- `?=` - Weak assignment (only if undefined)

**Spread operators:**
- `..` - Normal spread
- `*..` - Strong spread
- `?..` - Weak spread
- `..=` - Spread assignment (equivalent to `data = {..data value}`)

**Fallback operator:**
- `??` - Provide fallback value

**Special operators:**
- `~` - Shape morphing
- `???` - Placeholder for unimplemented code

## Scope Reference

Comp manages several scopes while statements are being executed.
Most scopes are referenced with the `$` and their name. There are also
a few utility scopes that are defined as a simple symbol for convenience.

**Named Scopes**

- `$out` - Represents the fields that have been defined for the structure
being generated by the current function or structure literal.
- `$in` - Represents the fields passed into the currently evaluating statement.
- `$arg` - Represents the arguments that have been passed into the current function.
- `$ctx` - Specially managed scope that passes fields down the call stack.
- `$mod` - Represents module level globals shared across the current module.

**Special Scopes**

- `@` - Scope is used for local temporaries inside of functions. 
- `^` - A combination of `$arg`, `$ctx`, and `$mod` morphed to the function argument shape.
- *(Unnamed)* - Bare fields used in a function represent a combination
of the `$out` and `$in` scopes. Any fields being generated are
automatically placed in the `$out` scope and become the current value for
this scope.

Several of these scopes have special rules about how they are managed and
accessed.

### Module Scope

The `$mod` scope is simply a shared global scope for fields. This scope can be
set at the global level of a module (outside of function calls) but only literal
values and pure functions can be used in this context.

The module scope is private, it cannot be accessed by code in other modules.

Modules can use the `!entry` definition to set more dynamic values into this
scope. When `!pure` functions are evaluating in the module they can only access
a copy of the `$mod` that was set at module definition time, before `!entry` was
run.

### Context Scope

Context scope is managed differently than most others. Every time a function is
invoked it inherits the `$ctx` scope from whatever called it. Any overrides to
this context are not preserved when the function stops executing.

This is included in the `^` scope, which allows a way to set function
arguments that will be visible deeper in the call stack. 

Any function can reset this context with a call to `$ctx = {}`. When `!pure`
functions are evaluating they will only be called with an empty context.

```comp
!func |parent = {
    $ctx.session-id = "abc123"
    data |child-function  ; $ctx.session-id is available in child
}

!func |child-function ~{data} = {
    ; Inherits $ctx.session-id from parent
    log-entry = {
        session = $ctx.session-id  ; also as ^session-id
        action = data.action
    }
}
```

### Statement Scopes

The `$in` and `$out` scopes are updated for every statement being run.
These both drive the state of the special *unnamed* scope, which is referenced
whenever bare field names are looked up.

Whenever a new pipeline begins executing, the `$in` value is reset to match
the state of whatever the containing function's `$in` represented. This allows
pipelines starting with function calls to share the incoming structure for
the function.

The `$in` scope represents the data from the incoming pipeline that has been
morphed to match the function's shape definition. It cannot be overwritten.

```comp
; Example showing $in scope reset
data = {name="Alice" age=30}

result = data |process .{
    ; Here, $in = {name="Alice" age=30}
    name = $in.name
    
    profile = .{
        ; $in resets here! Now $in = {} (empty structure being built)
        ; To access original data, must use explicit reference
        display-name = data.name  ; Not $in.name!
        age-group = data.age |categorize
    }

    admin? = (|if $out.name == "admin" #true #false)
}
```

The `$out` scope can be directly modified to build output structures incrementally:

```comp
!func |build-user ^{name ~str age ~num} = {
    ; Direct field assignment to $out
    $out.name = ^name
    $out.age = ^age
    $out.created = (|now)
    
    ; Append operations using spread-assignment
    $out ..= #active.status
    $out ..= (^name |calculate-permissions)
    
    ; Conditional additions
    (^age >= 18) |if .{
        $out.can-vote = #true
    }
}
```

This direct modification approach is particularly useful in privacy structures where automatic field export is disabled.

### Local Scope

This scope is used for function level temporaries. When the function completes
this scope is removed.

This scope is shared across any blocks defined inside the function. 
Modifications made to `@` variables within blocks are visible to
the rest of the function scope.

This scope is intended to be overwritten regularly.

```comp
!func |example = {
    @counter = 0
    
    result = data |process .{
        @counter = @counter + 1  ; Modifies function-level @counter
        value = @counter * 2
    }
    
    @final = @counter  ; Sees the modified value from the block
}
```

### Argument Scopes

The `$arg` scope is rarely accessed directly. It contains the direct arguments
supplied to the function. This scope cannot be overwritten.

Arguments will be more commonly references through the `^` scope. This contains
a combination of several scopes morphed into the shape for the function arguments.
If this morph cannot succeed then the function call is an immediate failure.
This scope cannot be overwritten.

To explicitly create the `^` scope the function preparation code makes a call
like `{..$mod ..$ctx ..$arg} ~function-arg-shape`.

```comp
; Developer knows exactly where values come from
$ctx.port = 8080
$mod.host = "default.com"

!func |connect ^{host ~str port ~num timeout ~num = 30} = {
    ; If ^port missing from all of {..$mod ..$ctx ..$arg}, 
    ; function fails at call site, not deep inside
}

; Function call with partial args
(|connect host="override.com")
; ^ becomes: {host="override.com" port=8080 timeout=30}
; - host from $arg (overrides $mod)
; - port from $ctx
; - timeout from shape default
```

### Inherited Scopes

**`$ctx` - Execution context**
- Follows the call stack, inherited by called functions
- Can be modified and passed down to subsequent calls
- Persists across function boundaries within the same execution chain

```comp
!func |outer = {
    $ctx.shared-data = "available everywhere"
    inner-data |inner-function
}

!func |inner-function ~{data} = {
    ; Can access $ctx.shared-data from outer function
    result = $ctx.shared-data + data.value
}
```

**`$mod` - Module scope**
- Global to the entire module
- Shared by all functions and definitions in the same file
- Persists for the lifetime of the module

```comp
; Module-level configuration
$mod.config = {database-url="localhost" timeout=30}

!func |connect = {
    ; All functions can access module scope
    connection = $mod.config.database-url |database.connect
}
```

## Concrete Types, Not Inference

Comp uses a fundamentally different approach to types than most modern languages. Instead of inferring types from context, Comp values carry their concrete types as intrinsic properties. This design choice affects error messages, performance, and how you reason about code.

### Values Have Types, Not Variables

In most languages, variables have types that are either declared or inferred:

```typescript
// TypeScript - variable 'x' has inferred type 'number'
let x = 42;

// Rust - variable 'items' has inferred type 'Vec<i32>'
let items = vec![1, 2, 3];
```

In Comp, values themselves carry type information:

```comp
; The value 42 IS a number - no variable typing needed
x = 42

; The structure IS this shape when created
data = {name="Alice" age=30}
```

### Morphing Creates Concrete Types

When you morph data with shapes, you get concrete typed values, not inferred types:

```comp
!shape ~user = {name ~str age ~num}

; This creates a concrete ~user typed value
user-data ~user = {name="Alice" age=30}

; Not inference - the morphing operation produces a definite ~user
validated = input-data ~user  ; Either succeeds (concrete ~user) or fails
```

### No Type Inference Complexity

Comp doesn't try to figure out what types "should be" - it works with what types "are":

```comp
; Clear: this number can't be used as string
age = 30
message = "User is " + age  ; ERROR: no string concatenation

; Clear: this structure doesn't match the shape
invalid-user ~user = {name="Bob"}  ; ERROR: missing required 'age' field

; Clear: morphing either works or doesn't
result = uncertain-data ~user  ; Either concrete ~user or morph failure
```

### Benefits of Concrete Types

**Clearer Error Messages:**
- "This number cannot be used as a string" instead of "type inference failed"
- "Structure missing field 'age' for shape ~user" instead of "cannot infer type"

**Predictable Performance:**
- No compilation time spent on complex inference algorithms
- Runtime knows exact types without inference overhead
- Morphing operations have deterministic, measurable costs

**Simpler Mental Model:**
- Values are what they are - no hidden type calculations
- Shapes transform data into known, concrete types
- Function dispatch works on actual types, not inferred ones

This approach makes Comp both simpler to understand and more predictable in behavior, though it requires a different mindset from languages that rely heavily on type inference.

## Spread Assignment

The spread-assignment operator `..=` provides a concise way to append data to existing structures. It acts as syntactic sugar for the common pattern of rebuilding a structure with additional unnamed fields.

```comp
; These are equivalent:
data ..= new-value
data = {..data new-value}

; Practical examples:
items ..= "new item"           ; Append item to list-like structure
config ..= {debug=#true}       ; Append structure as unnamed field
log ..= timestamp              ; Append timestamp value

; Works with all spread variants:
data *..= secure-value     ; Strong append (resists overwriting)
data ?..= default-value    ; Weak append (only if field undefined)

; Note: This is append, not merge
settings ..= {theme="dark"}    ; Adds {theme="dark"} as unnamed field
; Result: {..existing-settings {theme="dark"}}
; NOT: {..existing-settings theme="dark"}
```

The spread-assignment operator is particularly useful for building up list-like structures incrementally or for adding complete sub-structures as discrete elements.

## Documentation Syntax

The `!doc` operator attaches documentation to functions, shapes, and other definitions:

```comp
!doc "Process different types of data appropriately"
!func |save ~{data} = {
    ; Function implementation
}

; For polymorphic functions, use !doc impl for specific implementations
!doc impl "Saves to primary database"
!func |save ~{~database.record} = {
    ; Database-specific implementation
}
```

## Tokens

Tokens are used for naming everything in Comp. There are several rules for valid
token names.
* Tokens must follow the UAX #31 specification for valid unicode tokens
  * This matches the behavior of Python and Rust.
* The `ID_Continue` set is expanded to also include the ascii hyphen.

The language convention is to use all lowercase characters where writing purely
Comp specific identifiers. When interfacing with other languages or data
specifications, use capitalizations and underscores where preferred.

The style preference is to use the hyphens as word separators instead of
compacting token names into abnormal compound words.

The style of using lowercase words with hyphen separates is referred to as
**kebab-case**.

Allowed tokens (although not always preferred)
* `html5`
* `content-accept`
* `_parity_bit`
* `用户名`

### Kebab-Case and Arithmetic Disambiguation

Comp's use of kebab case makes typical subtraction operators ambigious.

Use of spacing, parenthesis, or a special `+-` operator can be used to
invoke subtraction on number values. Be aware that the language will treat
this as a regular subtraction, not as adding a the negative value. Since
subtraction is only allowed on number types, there is no techinical difference.

```comp
; Kebab-case identifiers are single tokens
user-name = Alice               ; Identifier: "user-name"
api-key = secret-value          ; Two identifiers: "api-key" and "secret-value"  
database-config = settings      ; Identifier: "database-config"

; Subtraction requires disambiguation
a - b                          ; Subtraction (spaced)
a+-b                           ; Explicit subtraction (no spaces needed)
(a)-(b)                        ; Clearly multiple tokens
```

## Comments

The language supports line comments using the style `;` of semicolon,
similar to Clojure and Lisp. There is no support for block style comments.

The language does not do any interpretation of the comment contents.
Everything from the begin of the comment to the end of the line is strictly
ignored.

See the section on Docstrings for related information.

## Nested Naming

Like tags, shapes and functions can define nested hierarchical names using dot notation. This provides organization and namespace capabilities similar to tags, enabling cleaner module organization and logical grouping of related definitions.

### Shape Hierarchies

Shapes can be defined with dotted names to create logical groupings:

```comp
; Database-related shapes
!shape ~database.connection = {host ~str port ~num}
!shape ~database.record = {id ~num data ~str}
!shape ~database.query = {sql ~str params ~str[]}

; HTTP-related shapes  
!shape ~http.request = {method ~str url ~str headers ~str{}}
!shape ~http.response = {status ~num body ~str headers ~str{}}

; Graphics shapes
!shape ~graphics.point = {x ~num y ~num}
!shape ~graphics.color = {r ~num g ~num b ~num a ~num = 1}
!shape ~graphics.transform = {..~graphics.point scale ~num = 1}
```

### Function Hierarchies

Functions can use the same dotted naming for organization:

```comp
; Database operations
!func |database.connect ~{config ~database.connection} = {
    ; Connection logic
}

!func |database.query ~{query ~database.query} = {
    ; Query execution
}

; HTTP utilities
!func |http.get ~{url ~str} = {
    ; GET request logic
}

!func |http.post ~{request ~http.request} = {
    ; POST request logic  
}

; Graphics operations
!func |graphics.translate ~{point ~graphics.point} ^{offset ~graphics.point} = {
    ; Translation logic
}
```

### Referencing Nested Names

Nested names are referenced using their full dotted path:

```comp
; Using nested shapes
user-record ~database.record = {id=123 data="user data"}

; Using nested functions  
(config |database.connect)
({sql="SELECT *" params=[]} |database.query)

; Shapes in function signatures
!func |save-user ~{user ~database.record} = {
    user |database.insert
}
```

This hierarchical organization follows the same principles as tag hierarchies—the most specific part comes first in the path, enabling natural grouping while maintaining clear, readable names.

## Core modules

Several important modules are defined as the core of the Comp language. These
are imported automatically into every module. These are mainly related to
managing the builtin datatypes and higher level flow control. 

* `.iter` working with iteration and sequences
* `.num` working with number values and mathematics
* `.path` working with path structure values
* `.store` working with mutable data storage
* `.str` working with string values
* `.struct` high level modifications and queries for structures
* `.tag` working with tag definitions, values, and hierarchies

From these libraries there are also several specially aliased
values that can be referenced in every module, without providing the
full namespace. This is a feature any module can configure for themselves
using ~alias operators. You can see these references are typed, based
on the type of object they contain

* `#break` iteration flow control to immediately stop processing
* `#false` false boolean tag value
* `#skip` iteration flow control to ignore a value (similar to a `continue` on other languages)
* `#true` true boolean tag value
* `~bool` shape for a boolean value
* `~nil` shape of an empty structure
* `~num` shape for a scalar numeric value
* `~str` shape for a scalar string value
* `|length` number of items in a structure

The `.iter` module provides core iteration functions and stream abstractions. For comprehensive coverage of iteration patterns, lazy evaluation, and stream processing, see [Iteration and Streams](loop.md).