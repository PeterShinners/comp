# General Syntax

* Listing of general purpose features in the Comp syntax. *

## Overview

Comp has many general purpose features, aside from the major topics like
modules, functions, shapes, and tags. Many of those topics share common
functionality that is better described in this document.

## Namespaces

Whenever a field name is referenced, it comes from one of several predefined
namespaces. Any function being executed exists in a stack of namespaces
that override each other to define all available fields.

This is separate from the function temporary namespace, where all variables
are prefixed with `$` dollar sign.

These are the namespaces fields are referenced from. Values in the more
specific bottom namespaces override those from the more general top
namespaces.

* `!mod` Represents data set inside the current module. This is a global
namespace only available to code inside the same module.
* `!ctx` A context that is passed through every function call.
* `!in` The structure that was passed to the running function.
* `!out` The structure being generated by the current function.

Field lookups will walk through each of these namespaces to find a matching
name.

Indexed field references can only come from the `!in` namespace.

Field assignments are always sent to the `!out` structure, which will then
be the new value used when that field is referenced again.

These namespaces can be referenced and assigned like regular structures.
Remember that field assignment is not modifiying the original namespace,
but provides a recipe how to modify a new copy of that structure.

```comp
!func :first ~nil = {
  !mod.port = 8000
  !mod.ip = "0.0.0.0"
  {port=8888} -> :second
}

!func :second ~{port} = {
  !ctx.port = port + 1000  ; 9888
  {ip="localhost"} -> :third
}

!func :third ~{ip} = {
  $cfg = {ip port}  ; {"localhost" 9888}
  $cfg -> :server/listen
}
```

These namespaces are readonly structures. When new threads are launched
they share a copy of the immutable data. When they modify new structures
they keep their own private copies.

## Privacy

Private and unexported data uses the `&` in different ways to prevent other
modules from accessing values and definitions. Remember this by tilting your
head and imagining the symbol represents a padlock.

Each module has a private namespace `!mod` that allows storing and updating data
that no code outside the current module can reference or modify.

### Private Definitions

Shape, function, and tag definitions that are internal for the module use only.
These definitions place an `&` ampersand as a suffix on the name. This also
applies to namespace aliases which are exported by default.

```comp
!func :secret_hash& ~str = {...}
!tag @attachment& = {precall postcall}
!shape bunker& = {width~num length~num depth~num}
```

The & suffix is not used when referencing private definitions. The privacy is an
access control mechanism, not part of the interface itself.

This also applies when using the `!alias` operator. Aliases default to being
exposed definitions for the module itself. Adding the `&` ampersand suffix
allows them to be used privately.

```comp
!alias :leftpad = :str/ljust    ; shared definition
!alias #logsev& = #log#severity ; private definition
```

### Private Data Attachment

Each module can attach private data to any structure using `&` syntax. Other
modules cannot access private data attached by different modules:

This private data exists outside the value itself, which means the shape is not
modified by hidden or internal fields.

Referencing and assigning private data can be done either individual fields or
the entire private structure.

```comp
; Create structure with private data inline
$user = {login="pete" email="pete@example.com"}&{session="abc123" id=789}

; Access private data (only in same module)
$user.login          ; "pete" - public field
$user&.session       ; "abc123" - private field (same module only)
$user&.id            ; 789 - private field (same module only)

; Manual private data assignment
$user& = {session="abc123", internal_id=789}
```

This private data is natually transferred to every value passed through a
pipeline's chain of statement. This includes full spread operators.

```comp
$user& = {session="abc", token="xyz"}

; Automatic preservation in pipelines
$result = $user -> :transform -> :validate
; $result& = {session="abc", token="xyz"}

; Automatic preservation in full spread
$copy = {...$user extra="field"}
; $copy& = {session="abc", token="xyz"}

; Manual copying when needed
$selective = {name=$user.name}
$selective& = $user&  ; Manual private data transfer
```

When the result of a structure comes from the combination of mutliple existing
structure then the private data will be merged, using "first reference wins"
collision rules. There is no way to override this merging behavior using strong
or weak operations.

When strict handling of private data is needed through complex merging
operations, the private data can always be saved and modified from earlier steps
in the operation, then applied back to the resulting object directly.

```comp
$source1& = {token="abc", shared="first"}
$source2& = {cache="xyz", shared="second"}

$merged = {field1=$source1.name, field2=$source2.email}
; $merged& = {token="abc", shared="first", cache="xyz"}
; First reference wins: $source1& merged before $source2&
```


## Docstrings

The language supports docstrings which are extended user information attached to
any shape, function, tag, or field. These are more powerful than comments
because they are recognized by the language and can be accessed at runtime.

A docstring is a string literal that follow the `!doc` operator. These can use
single or triple string quotes for single and multiline use cases. There are two
forms of these documentation strings.
* **Inline** is the simplest, it uses `!doc "Information"` to immediately apply
the docstring to whatever function, shape, tag, or field definition follows.
* **Detached** adds a reference to the object being documented, like `!doc
#severity = "Logging level strengths."

Docstrings for the module must use the detached form of `!doc module "Top level
info."`.

Multiple docstrings attached to the same definition are appended together in
file order, with a blank line inserted between each docstring. Docstring tools
will expect docstrings to use Markdown formatting to style the information.

Use inline `!doc` for:
* *Brief single-line descriptions
* *Simple field documentation

Use detached `!doc target` for:
* *Extended multi-paragraph documentation  
* *Documentation in separate files
* *Avoiding clutter in complex definitions
* *Module-level documentation (required)

More documentation guidelines:
* Single line summaries whould be written like a sentence with capitalization
  and punctuation.
* Multiple definitions of detached documentation will be joined with an empty
  line.
* When a definition only has a multiline detached docstring it should still
  include a summary line that is separated by a single blank line from the
  remaining documentation.

```comp
!tag #status = {
    pending={review approved rejected}
    !doc "Actively being developed."
    active
    !doc "All work completed and ready to deliver."
    complete
}

!doc #status "Workflow status indicators."
!doc #status#pending "Awaiting decision."
!doc #status#pending#review "Under active review."
!doc #status#pending#approved "Approved but not yet active."
```

Documentation strings are regular string literals and can include formatting
instructions `${}`. Documentation strings expanded in a special context that has
access to
* `field` lookup fields in the static module namespace
* `doc.toc` table of contents for the active object (module, shape, or tag)
* `describe` structure created using the `!describe` operator for the attached
  object

Documentation tools should attempt to auto-recognize references to functions
shapes and tags and generate properly linked references where possible.

It should not be necessary to document information clearly defined in the
language, like field shapes or default values. Tools displaying documentation
should also consider grouping multiple implementations of a function with the
same name, when defined with different shape signatures.


## Runtime Introspection

Definitions like functions and shapes are not referencable as values.
A `!describe` operator can be given any value or these types of references
to generate a description of that object.

This structure contains both runtime information and the static declarative
information about that value or reference. Each value or reference provides
different information

(Much of this data will be dependent on the implementation and expect to
be vastly changed.)

### Modules `!describe mod/` (aka, namespaces)

* `file` Path to file that generated this namespace, if loaded from a file
* `specifier` the original specifier string used to import this module
* `source` name of the source used for import
* `namespace` original namespace this was imported as
* `package` package information for this module (author, website, version)
* `tags` names of defined tags
* `funcs` names of defined functions (dispatch duplicates allowed?)
* `shapes` names of defined shapes
* `entry` info about entry pure function
* `main` info about main function

The lists of shapes, tags, and functions also include private values.
The values in the tags funcs and shapes should be usable somehow with
`!describe` to walk the namespace.

There are many common fields that describe will attempt to populate
for any of the types it is called on.

* `namespace` original namespace this was imported from (or none for current module)
* `file` Path to file that generated this function, if loaded from a file
* `line` Line number for `!func` definition
* `docs` optional documentation

### Functions `!decribe :func`

* `name` original name of function
* `shape` shape for function signature
* `blocks` optional named blocks with types
* `ast` definition of function body
* `permissions` explicitly defined permission requirements
* `pure?` if function is defined and invoked as pure
* `lazy?` if function defines a lazy structure

Functions will need some way to describe multiple implementations that
dispatch to different shapes. Perhaps it is a single entry name that has
multiple "implementations"?

### Shapes `!decribe ~shape`

* `name` original name of shape (empty if anonymous)
* `fields` names (or index) of each field

### Shape field `!describe ~shape.field`

* `shape` original namespace this was imported from (or none for current module)
* `position` index position of fields
* `name` optional name of field
* `shape` optional shape definition
* `default` optional default

### Tag `!describe ~tag`

* `name` name of leaf name
* `complete` the full name of the tag value
* `value` value assigned to tag
* `children` complete names of children tags
* `parent` complete name of parent 
* `base` root name for the tag
* `default` function for generating default values

### Value `!describe value`

All value descriptions have a several shared fields

* `type` enumeration of type
* `func` function that generated this value
* `statement` statement that generated this value

Build location might be tricky since readonly values will
be aggressively shared?

* structures *

* `fields` names (or index) of each field
* `shape` optional known explicit shape for data

* string *

* `unit` optional tag to define a unit

* number *

* `unit` optional tag to define a unit

* bool *

(has no additional description information)
