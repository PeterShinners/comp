# General Syntax and Language Features

*Core syntax rules, terminology, and general-purpose features of the Comp language*

## Overview

Comp has many general-purpose features beyond its major systems like modules, functions, shapes, and tags. This document defines the fundamental terminology, syntax rules, and shared functionality that underlies all Comp programs.

## Language Terminology

Understanding Comp requires precise terminology for its syntactic elements. These definitions establish the vocabulary used throughout the documentation.

**Statement** - The top-level unit of execution in a function body. A statement consists of an optional target (for assignment) followed by a pipeline. Statements are separated by whitespace and execute independently with fresh seeding from the context input.

**Pipeline** - A sequence of operations connected by the pipeline operator `->`. A pipeline can be a single operation (with implicit seeding) or multiple operations chained together. The data flows left-to-right through the pipeline.

**Operation** - A single transformative element within a pipeline. Operations include function references (`:validate`), structure constructors (`{x=10}`), literal values (`42`), string templates, and special operators like `!label`.

**Expression** - Any code that evaluates to a value. This includes literals, field references (`user.name`), arithmetic (`x + y`), comparisons (`age > 18`), and structure construction. Expressions appear within operations and blocks.

**Reference** - A named entity that isn't a value. Functions (`:process`), shapes (`~User`), and tags (`#status`) are references. Tags are unique in being both references and values depending on context - they can be passed as values, used as types, or referenced in hierarchies.

## Namespaces and Field Resolution

Field names in Comp are resolved through a layered stack of namespaces. Any undecorated token represents a lookup through these namespaces in priority order. Values in earlier namespaces override those in later ones.

The namespace stack consists of:
- `!out` - The structure being generated by the current function
- `..` - The structure passed as input to the current execution context  
- `!ctx` - Context inherited through function calls
- `!mod` - Module-specific shared data

When a field is referenced, the language searches each namespace in order until finding a match. Field assignments always target `!out`, creating or overriding fields in the output structure. This separation between input and output makes data flow explicit and prevents accidental mutations.

```comp
!func :process ~{port} = {
    !mod.default_port = 8000
    !ctx.override_port = 8080
    
    server_port = port          ; Uses parameter directly
    fallback = default_port     ; From !mod namespace
    final = override_port       ; From !ctx, overrides !mod
}
```

Indexed field references using `#` only search the input namespace. The namespaces themselves can be referenced and assigned like regular structures, though assignments create new structures rather than modifying originals.

## Privacy and Access Control

Comp uses the `&` symbol (imagine it as a padlock) to control access to data and definitions. Privacy operates at module boundaries - each module can have private definitions invisible to importers and private data attached to structures that only it can access.

Private definitions use `&` as a suffix on the name. These definitions - whether functions, shapes, or tags - are only accessible within the defining module. The suffix is not part of the name when referencing; it only marks the definition as private during declaration.

```comp
!func :public_api ~{data} = {
    data -> :validate -> :internal_process&
}

!func :internal_process& ~{data} = {
    ; Only accessible within this module
    data -> :transform -> :store
}

!shape ~InternalState& = {
    cache ~Store&
    pending_operations ~num
}
```

Modules can attach private data to any structure. This data exists separately from the structure's fields, preserving the structure's shape while carrying module-specific information. Private data is accessed with the `&` operator and automatically flows through pipeline operations.

```comp
; Attach private data during creation
$user = {name="Alice" role="admin"} & {session_id=123 token="xyz"}

; Access private fields (only in same module)
$user.name           ; "Alice" - public field
$user&.session_id    ; 123 - private field

; Private data flows through pipelines
$result = $user -> :transform -> :validate
; $result& still contains {session_id=123 token="xyz"}
```

When multiple structures with private data are combined, the private data merges using first-reference-wins for conflicts. The merge cannot be influenced by strong or weak operators - it always follows the same rule for predictability.

## Documentation with Docstrings

Docstrings provide runtime-accessible documentation for definitions. Unlike comments, docstrings are recognized by the language and available for introspection. They use the `!doc` operator with either inline or detached forms.

Inline documentation immediately precedes the definition it documents. Detached documentation references the target explicitly, allowing documentation to be organized separately or added to existing definitions. Multiple docstrings for the same target are concatenated with blank lines between them.

```comp
!doc "Calculate the area of geometric shapes"
!func :area ~{shape} = {
    shape -> :match
        .{radius} .{radius * radius * 3.14159}
        .{width height} .{width * height}
        .{base height} .{base * height / 2}
}

!doc :area """
Additional notes: 
- Circles use radius field
- Rectangles use width and height
- Triangles use base and height
"""

!shape ~Config = {
    !doc "Server port number (1-65535)"
    port ~num = 8080
    
    !doc "Maximum concurrent connections"  
    max_connections ~num = 100
}
```

## Runtime Introspection

The `!describe` operator generates structural descriptions of values and references at runtime. This enables debugging, tooling, and metaprogramming by exposing internal information about any Comp entity.

Common fields across all descriptions include the source file and line number (when available), namespace origin, associated documentation, and type information. The specific details vary by entity type but follow consistent patterns.

```comp
; Describing a function
:my_func -> !describe
; Returns structure with: name, shape, blocks, permissions, source location

; Describing a value  
{x=10 y=20} -> !describe
; Returns structure with: type, fields, shape (if explicit), creation context

; Describing a module
!describe mod/utils
; Returns structure with: functions, shapes, tags, imports, package info
```

The introspection system provides enough information for development tools, debuggers, and runtime analysis without exposing implementation details. Pure functions can be identified, shape compatibility can be verified, and error messages can include precise source locations.

## Comparison and Equality

Comp provides two families of comparison operators with distinct semantics. Equality operators (`==`, `!=`) test for structural equivalence, while ordering operators (`<`, `>`, `<=`, `>=`) determine sort order. All comparisons are deterministic and never fail - they always produce a boolean result.

Equality comparison uses strict structural matching. Scalars auto-wrap to single-element structures for comparison, so `5 == {5}` is true. Named fields must match by name and value regardless of order. Unnamed fields must match by position and value. No type coercion or shape morphing occurs during equality testing.

Ordering comparison establishes a total order over all values. The empty struct `{}` is less than all other values. Different types compare by priority: booleans < tags < numbers < strings < structures. Structures compare lexicographically - first by matching named fields alphabetically, then by positional fields left-to-right.

```comp
; Equality ignores named field order
{x=1 y=2} == {y=2 x=1}        ; true

; Ordering is deterministic across types  
{} < #false < 0 < "a" < {x=1}  ; true

; Complex structure ordering
{a=1 z=3} < {a=2 b=1}         ; true (a field compared first)
{name="Alice"} < {name="Bob"}  ; true (string comparison)
```

## Mathematical and Logical Operators

Comp reserves arithmetic operators exclusively for numeric types. There is no operator overloading - each operator has one fixed meaning. Numbers support the standard mathematical operations: `+` (addition), `-` (subtraction), `*` (multiplication), `/` (division), `%` (modulo), and `**` (exponentiation). Division always produces exact rational results without truncation.

Boolean values use separate logical operators that short-circuit during evaluation. The `&&` operator returns true when both operands are true. The `||` operator returns true when either operand is true. The `!!` operator negates a boolean value. These operators stop evaluating as soon as the result is determined.

String manipulation uses explicit functions rather than operators. There is no string concatenation operator - use templates or functions like `:str/concat` instead. This design choice keeps operators unambiguous and prevents confusion about types.

## Fallback Operator

The `|` operator provides immediate fallback values for operations that might fail. It operates at lower precedence than pipeline operators and provides its alternative value only when the primary expression fails or references an undefined field. Multiple fallbacks can chain to create cascading defaults.

```comp
; Field access with defaults
config.port | env.PORT | 8080

; Computed fallbacks
user.timeout | (user.retry_count * 1000) | 5000

; Nested fallback chains
cache.get(key) | database.fetch(key) | generate_default(key)
```

## Weak and Strong Assignment Variants

Assignment operators have three variants that control how conflicts are resolved. Normal assignment (`=`) overwrites existing values. Strong assignment (`*=`) creates sticky values that resist overwriting. Weak assignment (`?=`) only assigns if the field doesn't already exist.

These variants apply consistently across different contexts - field assignments, spread operations, function definitions, and shape morphing. When the same field is assigned multiple times with different strengths, strong assignments win over normal, which win over weak.

```comp
; Field assignment variants
config = {
    port *= 8080      ; Strong - resists override
    host = "localhost" ; Normal
    timeout ?= 30      ; Weak - only if not set
    
    port = 3000       ; Ignored - strong assignment wins
    host = "0.0.0.0"  ; Overwrites normal assignment
    timeout = 60      ; Would override if timeout wasn't already 30
}

; Spread operator variants
result = {
    ...defaults       ; Normal spread
    ..*required      ; Strong spread - these fields stick
    ..?optional      ; Weak spread - only missing fields
}
```

## Comments and Style

Line comments use `;` and continue to the end of the line. There are no block comments. The semicolon style comes from Lisp traditions and distinguishes comments from the `//` path operator.

```comp
; Main configuration handler
!func :configure ~{options} = {
    port = options.port | 8080  ; Use default if not specified
    
    ; Validate port range
    :when .{port < 1 || port > 65535} .{
        {#fail#config message="Invalid port: ${port}"}
    }
}
```

The standard style uses tabs for indentation, lowercase-with-hyphens for names (lisp-case), and positions operators at the start of continuation lines. Lines should stay under 100 characters when reasonable. Structure definitions indent their contents one level, with opening braces on the preceding line and closing braces at the original indentation level.