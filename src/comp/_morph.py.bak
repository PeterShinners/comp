"""Shape morphing and type checking logic."""

__all__ = ["MorphResult", "morph", "strong_morph", "weak_morph", "mask", "strict_mask"]

import comp


class MorphResult:
    """Result of a morph operation containing both score and morphed value.

    The score tuple: (named_matches, tag_depth, assignment_weight, positional_matches)
    determines how well the value matched the shape. Higher scores are better matches.

    The value is the morphed result, or None if morphing failed.
    """
    __slots__ = ("named_matches", "tag_depth", "assignment_weight", "positional_matches", "value")

    def __init__(self, named_matches=0, tag_depth=0, assignment_weight=0, positional_matches=-1, value=None):
        self.named_matches = named_matches
        self.tag_depth = tag_depth
        self.assignment_weight = assignment_weight
        self.positional_matches = positional_matches
        self.value = value

    def as_tuple(self):
        """Get the score components as a tuple for comparison."""
        return (self.named_matches, self.tag_depth, self.assignment_weight, self.positional_matches)

    def __gt__(self, other):
        """Lexicographic comparison - earlier components more important."""
        return self.as_tuple() > other.as_tuple()

    def __lt__(self, other):
        return self.as_tuple() < other.as_tuple()

    def __eq__(self, other):
        if not isinstance(other, MorphResult):
            return False
        return self.as_tuple() == other.as_tuple()

    def __repr__(self) -> str:
        value_info = f" value={self.value}" if self.value else " (no match)"
        return (f"MorphResult(named={self.named_matches}, tag={self.tag_depth}, "
                f"weight={self.assignment_weight}, pos={self.positional_matches}{value_info})")

    @property
    def success(self):
        """Check if the morph succeeded (has a value)."""
        return self.value is not None


def morph(value, shape):
    """Morph a value to match a shape, returning both score and morphed value.

    Non-struct values are wrapped in single-item unfielded structures first,
    so the morphing logic only needs to handle structures.

    Returns a MorphResult with:
    - Score components (named_matches, tag_depth, assignment_weight, positional_matches)
    - value: the morphed Value, or None if morphing failed

    For unions, tries all variants and returns the best match.
    """
    # Track if we wrapped a non-struct value
    was_wrapped = False

    # Wrap non-struct values in a single-item structure
    if not value.is_struct:
        was_wrapped = True
        wrapped = comp.Value({})
        wrapped.data[comp.Unnamed()] = value
        value = wrapped

    # Delegate to internal morphing (handles unions and structs)
    result = _morph_any(value, shape)

    # Unwrap if we wrapped AND the target shape is a primitive (not structural)
    # This handles cases like: 5 ~num (stay unwrapped)
    # But NOT: 5 ~{~num} (should stay wrapped in struct)
    if was_wrapped and result.success and result.value is not None:
        # Only unwrap for primitive target shapes (~num, ~str, tag constraints)
        is_primitive_target = (
            isinstance(shape, comp.ShapeDefinition) and
            shape.full_name in ("num", "str", "bool", "tag", "any")
        )

        if is_primitive_target and result.value.is_struct:
            # Unwrap single-item struct
            if len(result.value.data) == 1:
                single_key = next(iter(result.value.data.keys()))
                result.value = result.value.data[single_key]

    return result


def _morph_any(value, shape):
    """Internal morph function that handles any value without wrapping.

    This is used for recursive morphing of field values where we don't want
    to wrap non-struct values in an extra layer.

    Args:
        value: The value to morph (struct or non-struct)
        shape: The shape to morph to

    Returns:
        MorphResult with the morphed value or failure
    """
    # Handle unions by trying all variants and picking the best
    if hasattr(shape, 'variants'):  # ShapeUnion check
        best_result = MorphResult()  # Zero score, no value

        for variant in shape.variants:
            variant_result = _morph_any(value, variant)
            if variant_result.success and variant_result > best_result:
                best_result = variant_result

        return best_result

    # For non-union shapes, delegate to the appropriate handler
    # Struct values go to _morph_struct, primitives to _morph_primitive
    return _morph_struct(value, shape)


def _morph_primitive(value, type_name):
    """Morph a value to a primitive type (~num, ~str).

    Rules:
    1. If value is a structure with exactly one unnamed field, unwrap it
    2. If value matches the expected type, return it
    3. Otherwise, fail (no type conversion)

    Args:
        value: The value to morph (may be struct or primitive)
        type_name: The primitive type name ("num" or "str")

    Returns:
        MorphResult with the morphed value or failure
    """
    # Step 1: Unwrap single-item structures (for top-level morph calls)
    # If called from recursive morph, value may already be a primitive
    # Accept both unnamed and named single fields: {5} ~num or {a=5} ~num
    if value.is_struct and len(value.data) == 1:
        single_key = next(iter(value.data.keys()))
        # Unwrap regardless of whether field is named or unnamed
        value = value.data[single_key]

    # Step 2: Check if value matches the expected type
    if type_name == "num":
        if value.is_number:
            return MorphResult(positional_matches=0, value=value)
            
    elif type_name == "str":
        if value.is_string:
            return MorphResult(positional_matches=0, value=value)
            

    # Step 3: Type mismatch - fail the morph
    return MorphResult()
