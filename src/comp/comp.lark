// Comp Language Grammar v2 - Clean Restart
//
// Starting from the ground up with just literals and identifiers.
// Focus on simplicity and letting the grammar do the work, not the transformer.
//
// DESIGN PRINCIPLES:
// - Grammar rules should be self-explanatory
// - Minimize transformer complexity
// - Clear separation of concerns
// - Declarative over imperative

// === ENTRY POINTS ===

// Module-level parsing (default - for complete .comp files)
start: module

// Module contains zero or more module-level statements
module: module_statement*

// Module-level statements (definitions and top-level expressions)
?module_statement: import_statement
                 | tag_definition
                 | shape_definition
                 | function_definition
                 | expression         // Allow expressions for REPL/testing compatibility

// Expression-level parsing (for REPL, testing, embedded evaluation)
// Access via Lark's start parameter: Lark(..., start="expression_start")
expression_start: expression

// === BASIC TOKENS ===

// Comments
COMMENT: /;[^\r\n]*/
%ignore COMMENT
%ignore /\s+/

// === NUMBER LITERALS ===
// Identifies integer only values with bases, which need different parsing
// route. Allow underscores for readability.
// Leading signs are handled by unary operators

number: INTBASE | DECIMAL

// Based number formats - unsigned, signs handled by unary operators
INTBASE.2: /0[xXbBoO](_?[\da-zA-Z])+/                      // All bases: hex, binary, octal

// Decimal formats - unsigned, signs handled by unary operators
DECIMAL.1: /(([1-9](_?\d)*)|0(_?0)*)/                      // Integer: 123, 1_000, 0, 0_0
         | /\d(_?\d)*\.(\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?/  // Decimal: 3.14, 5., 1.5e-10, 5.e10
         | /\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?/              // Leading dot: .5, .123_456, .5e10
         | /\d(_?\d)*[eE][+-]?\d(_?\d)*/                   // Scientific integer: 1e5, 1_000e10


// === STRING LITERALS ===
// String parsing with separated quotes and content.
// Uses Python's regex patterns but separates quotes from content in parse tree.
DUBQUOTE: "\""
SIXQUOTE:  "\"\"\""
SHORT_STRING_CONTENT: /(?:[^"\\\r\n]|\\.)+/i
_short_string: DUBQUOTE SHORT_STRING_CONTENT? DUBQUOTE

LONG_STRING_CONTENT: /(.|\n)+?(?=""")/is
_long_string: SIXQUOTE LONG_STRING_CONTENT? SIXQUOTE

string: _short_string | _long_string

// === IDENTIFIER FIELDS ===

// The simplest name token for an identifier, UAX #31 compliant
// Allows dashes and single optional trailing question mark
TOKEN: /[^\W\d][\w-]*[?]?/
INDEXFIELD: /#\d+/

// Individual field types - explicit rules for each context
tokenfield: TOKEN
indexfield: INDEXFIELD                              // #0, #1, #2 (literal)
          | "#" "(" expression ")"                  // #(expr), #(@index), #([|:stream])
stringfield: string
computefield: "'" expression "'"

// Scope field types
scope: "$" TOKEN

// Field components that can appear in identifiers
// First field in a chain (cannot be a string literal - that would be standalone)
?identifier_first_field: tokenfield | indexfield | computefield

// Fields after a dot (can include strings for quoted field names like obj."field")
?identifier_next_field: tokenfield | indexfield | string | computefield

// Identifier uses the $scope.field pattern or is a bare field reference
// Examples: $var.name, $arg.value, $ctx.field, $mod.export, foo.bar
// Bare scope markers are also identifiers: $var, $mod
identifier: scope ("." identifier_next_field)*                          // $var.foo
          | identifier_first_field ("." identifier_next_field)*         // foo.bar

_qualified: identifier


// === REFERENCE LITERALS ===
// References to tags, shapes, and functions. Possibly from other namespaces.
reference_identifiers: TOKEN ("." TOKEN)*
reference_namespace: "/" TOKEN?
_reference_path:  reference_identifiers reference_namespace?
tag_reference: "#" _reference_path
shape_reference: "~" _reference_path
function_reference: "|" _reference_path
_function_piped: "|" _reference_path  // ignored for pipeline parsing


// === MODULE-LEVEL DEFINITIONS ===

// Tag definitions (!tag)
// Supports multiple styles:
//   Simple:     !tag #status
//   Nested:     !tag #status = {#active #inactive}
//   Flat:       !tag #status.error.timeout
//   Hierarchical: !tag #status = {#error = {#timeout #network}}
// Note: Tag definitions cannot include module namespace (no /module suffix)
BANG_TAG: "!tag"

tag_definition: BANG_TAG tag_path                                           -> tag_simple
              | BANG_TAG tag_path tag_generator ASSIGN tag_value tag_body   -> tag_gen_val_body
              | BANG_TAG tag_path tag_generator ASSIGN tag_value            -> tag_gen_val
              | BANG_TAG tag_path tag_generator ASSIGN tag_body             -> tag_gen_body
              | BANG_TAG tag_path ASSIGN tag_value tag_body                 -> tag_val_body
              | BANG_TAG tag_path ASSIGN tag_value                          -> tag_val
              | BANG_TAG tag_path ASSIGN tag_body                           -> tag_body_only

tag_path: "#" reference_identifiers                       // Tag path without namespace

tag_generator: function_reference | block                 // Generator function or inline block

tag_body: LBRACE tag_child* RBRACE                        // {children...}

tag_child: tag_path                                       -> tagchild_simple
         | tag_path ASSIGN tag_value tag_body             -> tagchild_val_body
         | tag_path ASSIGN tag_value                      -> tagchild_val
         | tag_path ASSIGN tag_body                       -> tagchild_body

// Tag values are build-time constant expressions without structures/blocks
// Supports: literals (42, "text"), references (#tag, ~shape), arithmetic (1+2, 3*4), comparisons
tag_value: tag_arithmetic

?tag_arithmetic: tag_term
               | tag_arithmetic "+" tag_term   -> binary_op
               | tag_arithmetic "-" tag_term   -> binary_op

# ?tag_bitwise: tag_comparison bitwise ops would land here in priority

?tag_term: tag_comparison
         | tag_term "*" tag_comparison   -> binary_op
         | tag_term "/" tag_comparison   -> binary_op

?tag_comparison: tag_unary
               | tag_comparison "<" tag_unary   -> binary_op
               | tag_comparison ">" tag_unary   -> binary_op
               | tag_comparison "<=" tag_unary  -> binary_op
               | tag_comparison ">=" tag_unary  -> binary_op
               | tag_comparison "==" tag_unary  -> binary_op
               | tag_comparison "!=" tag_unary  -> binary_op

?tag_unary: tag_atom
          | "+" tag_unary  -> unary_op
          | "-" tag_unary  -> unary_op
          | "!" tag_unary  -> unary_op

// Atoms allowed in tag values - excludes structure, block, pipeline
?tag_atom: number
         | string
         | _qualified          // References: #tag, ~shape, |func, @local, $placeholder
         | paren_expr          // Parenthesized expressions


// === SHAPE DEFINITIONS ===

// Shape definitions (!shape)
// Supports simple and complex shapes:
//   Simple:     !shape ~point = {x ~num y ~num}
//   Defaults:   !shape ~point = {x ~num = 0 y ~num = 0}
//   Optional:   !shape ~user = {name ~str email? ~str}
//   Nested:     !shape ~circle = {pos ~{x ~num y ~num} radius ~num}
//   Spread:     !shape ~point3d = {..~point z ~num}
//   Union:      !shape ~result = ~success | ~error
// Note: Shape definitions cannot include module namespace (no /module suffix)
BANG_SHAPE: "!shape"

shape_definition: BANG_SHAPE shape_path ASSIGN shape_body

shape_path: "~" reference_identifiers                     // Shape path without namespace

shape_body: LBRACE shape_field* RBRACE                    // Shape with fields
          | shape_type (ASSIGN expression)?               // Alias or union, optionally with default

?shape_field: shape_spread                                // ..~shape (spread)
            | shape_field_def                             // field? ~type = default

shape_field_def: TOKEN QUESTION? shape_type? (ASSIGN expression)?  // Named field
               | shape_type (ASSIGN expression)?          // Positional field (no name)

shape_spread: SPREAD shape_type                           // ..~shape

// Union is now a separate rule that creates a flat list
shape_union: shape_type_atom (PIPE shape_type_atom)+      // ~type1 | ~type2 | ~type3

// Renamed to shape_type_atom - individual type without union
shape_type_atom: shape_reference                          // ~typename
               | tag_reference                            // #tagname (tag as type)
               | shape_inline                             // ~{...} inline shape
               | shape_block                              // ~:{...} block with input shape

// Inline anonymous shape definition
shape_inline: TILDE LBRACE shape_field* RBRACE            // ~{fields...}

// Block type definition - specifies the input shape the block expects
shape_block: TILDE COLON_BLOCK_START shape_field* RBRACE  // ~:{input-shape}

// shape_type can be a union or a single atom
shape_type: shape_union | shape_type_atom

TILDE: "~"
HASH: "#"
PIPE: "|"
QUESTION: "?"


// === IMPORT STATEMENT ===
BANG_IMPORT: "!import"

// Import statement: !import /namespace = source "path"
// Examples:
//   !import /math = std "core/math"
//   !import /utils = comp "./lib/utils"
//   !import /numpy = python "numpy"
import_statement: BANG_IMPORT SLASH TOKEN ASSIGN import_source string

// Import sources: std, comp, python, etc.
import_source: TOKEN

SLASH: "/"


// === FUNCTION DEFINITION ===
BANG_FUNC: "!func"
ARG_KEYWORD: "arg"

function_definition: BANG_FUNC function_path function_shape ARG_KEYWORD shape_type _assignment_op structure  -> func_with_args
                   | BANG_FUNC function_path function_shape _assignment_op structure                         -> func_no_args

function_path: PIPE TOKEN ("." TOKEN)*

function_shape: shape_type


// === STRUCTURE DEFINITION ===
LBRACE: "{"
RBRACE: "}"
LBRACKET: "["
RBRACKET: "]"
COLON_BLOCK_START: ":{"
SPREAD: ".."
structure: LBRACE _structure_content RBRACE
block: COLON_BLOCK_START _structure_content RBRACE
_structure_content: structure_op*
?structure_op: structure_spread | structure_assign | structure_unnamed
structure_spread: SPREAD expression
structure_assign: _qualified _assignment_op expression
structure_unnamed: expression


// === ASSIGN EXPRESSIONS ===
// Assignments are not part of basic expressions, they are handled at specific
// points in the grammar
ASSIGN: "="
STRONG_ASSIGN: "=*"
WEAK_ASSIGN: "=?"
SPREAD_ASSIGN: "..="
STRONG_SPREAD_ASSIGN: "..=*"
WEAK_SPREAD_ASSIGN: "..=?"
_assignment_op: ASSIGN | STRONG_ASSIGN | WEAK_ASSIGN | SPREAD_ASSIGN | WEAK_SPREAD_ASSIGN | STRONG_SPREAD_ASSIGN


// === BASIC ATOM ===

// Atoms: the basic building blocks
LPAREN: "("
RPAREN: ")"
PLACEHOLDER: "???"
placeholder: PLACEHOLDER

// Parenthesized expressions - simple grouping only (no pipelines)
?paren_expr: LPAREN expression RPAREN

// Pipeline expressions - now use square brackets
pipeline_expr: LBRACKET pipeline RBRACKET                           -> pipeline_unseeded
             | LBRACKET _pipeline_seed_expression pipeline RBRACKET -> pipeline_seeded

// Atoms only match single entities
// String is an atom (standalone literal), but can also appear as a field via stringfield
?atom: number
     | string
     | _qualified
     | tag_reference
     | structure
     | block
     | placeholder
     | paren_expr
     | pipeline_expr


// Entry to the expression grammar
?expression: _prepipeline_expression

// === PIPELINE EXPRESSIONS ===
// Pipelines now use square brackets: [seed |op1 |op2] or [|op]
// PIPE_FUNC: "|"
PIPE_FALLBACK: "|?"
PIPE_STRUCT: "|{"
PIPE_WRENCH: "|-|"
PIPE_BLOCK: "|:"
pipe_func: function_reference function_arguments
pipe_struct: PIPE_STRUCT structure_op* RBRACE
pipe_fallback: PIPE_FALLBACK expression
pipe_block: PIPE_BLOCK _qualified
pipe_wrench: PIPE_WRENCH _function_piped
pipeline: (pipe_func | pipe_struct | pipe_block | pipe_wrench | pipe_fallback)+

function_arguments: structure_op*

// === BASIC EXPRESSIONS ===

// Expression level that excludes pipelines - used for function arguments
// and other contexts where pipelines should not be parsed
_prepipeline_expression: or_expr

// Pipeline seed expression - like _prepipeline_expression but excludes morph_union
// to avoid ambiguity with pipeline operator |
_pipeline_seed_expression: or_expr_no_union

?or_expr_no_union: and_expr_no_union | or_expr_no_union LOGICAL_OR and_expr_no_union -> binary_op
?and_expr_no_union: not_expr_no_union | and_expr_no_union LOGICAL_AND not_expr_no_union -> binary_op
?not_expr_no_union: comparison_no_union | LOGICAL_NOT not_expr_no_union -> unary_op
?comparison_no_union: morph_expr_no_union | comparison_no_union comp_op morph_expr_no_union -> binary_op
?morph_expr_no_union: arith_expr
                    | morph_expr_no_union "~" morph_type_base -> morph_op
                    | morph_expr_no_union STRONG_MORPH morph_type_base -> strong_morph_op
                    | morph_expr_no_union WEAK_MORPH morph_type_base -> weak_morph_op

// Boolean operators
LOGICAL_AND: "&&"
LOGICAL_OR: "||"
LOGICAL_NOT: "!!"
?or_expr: and_expr | or_expr LOGICAL_OR and_expr -> binary_op
?and_expr: not_expr | and_expr LOGICAL_AND not_expr -> binary_op
?not_expr: comparison | LOGICAL_NOT not_expr -> unary_op

// Comparison operators
EQUAL_EQUAL: "=="
NOT_EQUAL: "!="
LESS_THAN: "<"
LESS_EQUAL: "<="
GREATER_THAN: ">"
GREATER_EQUAL: ">="
?comp_op: EQUAL_EQUAL | NOT_EQUAL | LESS_THAN | LESS_EQUAL | GREATER_THAN | GREATER_EQUAL
?comparison: morph_expr | comparison comp_op morph_expr -> binary_op

// Shape morph operators
// Morph: Transforms data to match a shape specification
// - Normal (~): apply defaults, allow extra fields
// - Strong (~*): no extra fields allowed, strict matching
// - Weak (~?): missing fields acceptable, partial matching
STRONG_MORPH: "~*"
WEAK_MORPH: "~?"

// Shape type in morph/mask context
// Accepts both bare identifiers (cat | dog) and full references (~cat | ~dog)
?morph_type: morph_type_base
           | morph_union                                  // cat | dog or ~cat | ~dog

?morph_type_base: reference_identifiers reference_namespace?   // shapename or module.shape
                | tag_reference                                // #tag
                | shape_reference                              // ~shapename (full syntax)
                | shape_inline                                 // ~{...}
                | morph_inline                                 // {...} (without ~)

// Inline shape without leading ~ for morph context
morph_inline: LBRACE shape_field* RBRACE

morph_union: morph_type_base (PIPE morph_type_base)+

?morph_expr: arith_expr
           | morph_expr "~" morph_type -> morph_op
           | morph_expr STRONG_MORPH morph_type -> strong_morph_op
           | morph_expr WEAK_MORPH morph_type -> weak_morph_op

// Number operators
PLUS: "+"
MINUS: "-"
KEBAB_MINUS: "+-"  // Disambiguation for subtraction vs kebab-case identifiers
MULTIPLY: "*"
DIVIDE: "/"
MODULO: "%"
POWER: "**"
?arith_expr: term  // Arith (+, -, +-)
           | arith_expr PLUS term -> binary_op
           | arith_expr MINUS term -> binary_op
           | arith_expr KEBAB_MINUS term -> binary_op
?term: unary  // Terms (*, /, %)
     | term MULTIPLY unary -> binary_op
     | term DIVIDE unary -> binary_op
     | term MODULO unary -> binary_op
?unary: power  // Factors (unary +/-)
       | PLUS unary -> unary_op
       | MINUS unary -> unary_op
?power: atom_in_expr  // Power (**) - right-associative
      | atom_in_expr POWER unary -> binary_op


// === ATOM EXPRESSIONS ===
// Use of atoms to continue building expressions
FALLBACK: "??"
?atom_in_expr: atom
             | atom_in_expr "." identifier_next_field -> atom_field
             | atom_in_expr FALLBACK expression -> atom_fallback
//          //  | atom_in_expr PRIVATEATTACH -> atom_private
//          //  | atom_in_expr PRIVATEFIELD identifier -> atom_private_field

