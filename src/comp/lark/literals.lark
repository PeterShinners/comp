// Comp Language Grammar - Literals and Basic Tokens
//
// Consolidates all literal types: numbers, strings, identifiers, references
// Provides clean foundation for expression parsing
//
// PURPOSE:
// - Single source of truth for all literal token definitions
// - Clean separation between tokenization and expression parsing
// - Reusable components for future grammar extensions
// - Consistent handling of UAX #31 identifier rules

// === NUMBER LITERALS ===
// Adapted from Lark's Python grammar but simplified for our needs
// Two number types based on parsing needs:
// - BASED: Can use ast.literal_eval (hex, binary, octal with signs and underscores)  
// - DECIMAL: Must use Decimal() directly (precision preservation)

number: BASED | DECIMAL

// Based number formats - unsigned, signs handled by unary operators
BASED.2: /0[xXbBoO](_?[\da-zA-Z])+/    // All bases: hex, binary, octal - no signs

// Decimal formats - unsigned, signs handled by unary operators  
DECIMAL.1: /(([1-9](_?\d)*)|0(_?0)*)/                               // Integer: 123, 1_000, 0, 0_0 - no signs
         | /\d(_?\d)*\.(\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?/            // Decimal: 3.14, 5., 1.5e-10, 5.e10
         | /\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?/                        // Leading dot: .5, .123_456, .5e10  
         | /\d(_?\d)*[eE][+-]?\d(_?\d)*/                             // Scientific integer: 1e5, 1_000e10


// === STRING LITERALS ===
// String parsing with comprehensive escape sequence support.
// Handles basic strings, escaped content, and Unicode escapes.

string: BASIC_STRING

// Basic string with escape sequences (double quotes only)
BASIC_STRING: /"([^"\\]|\\.)*"/


// === IDENTIFIERS ===
// Identifier tokenization following UAX #31 + hyphen rules.
// 
// UAX #31 Rules:
// - ID_Start: Letters, Letter_numbers, underscore
// - ID_Continue: ID_Start + Mark_nonspacing, Mark_spacing_combining, Decimal_numbers, Connector_punctuation
// - Plus Comp extension: hyphens allowed in continue position
// - Plus Comp extension: optional trailing ? for boolean-style identifiers

// More precise identifier token following UAX #31
// Start: letter, underscore, or other ID_Start characters  
// Continue: ID_Start + digits, marks, hyphens
// Optional trailing ? for boolean style
IDENTIFIER.1: /[^\W\d][\w-]*[?]?/

// Rule to create AST node
identifier: IDENTIFIER

// Token for full identifier paths (hierarchy with dots, optional module with slash)
IDENTIFIER_PATH: IDENTIFIER ("." IDENTIFIER)* ("/" IDENTIFIER)?


// === REFERENCE LITERALS ===
// Reference literal tokens for tags (#tag), shapes (~shape), and functions (|function)
//
// Following the unified pattern: sigil + identifier[.identifier]*/[identifier]
// Examples: #active, ~num, |connect, #error.status, ~record/database, #timeout.error.status/std

// Reference rules using simple tokens for fromToken pattern
tag_reference: "#" IDENTIFIER_PATH
shape_reference: "~" IDENTIFIER_PATH  
function_reference: "|" IDENTIFIER_PATH


// === INDEX NUMBERS ===
// Simple unsigned integers for array indexing  
INDEX_NUMBER: /\d+/