// Comp Language Grammar - Main Entry Point
//
// Main expression grammar following Python's precedence model with Comp-specific extensions
//
// ORGANIZATION:
// - literals.lark: All literal types (numbers, strings, identifiers, references)  
// - comp.lark: Main expression grammar with operators and constructs (this file)
//
// DESIGN PRINCIPLES:
// - Clean separation between literals and expressions
// - Organized by precedence (lowest to highest)
// - Clear sections for operators, constructs, and future extensions
// - Minimal duplication, maximum clarity

// Import all literal types
%import literals (number, string, identifier, tag_reference, shape_reference, function_reference, INDEX_NUMBER)

// === COMMENTS ===
COMMENT: /;[^\r\n]*/

%ignore COMMENT
%ignore /\s+/

// === OPERATORS ===
// Mathematical operators
PLUS: "+"
MINUS: "-"
SUBTRACT: "+-"  // Disambiguation for subtraction vs kebab-case identifiers
MULTIPLY: "*"
DIVIDE: "/"
MODULO: "%"
POWER: "**"
EQUAL_EQUAL: "=="
NOT_EQUAL: "!="
LESS_THAN: "<"
LESS_EQUAL: "<="
GREATER_THAN: ">"
GREATER_EQUAL: ">="
LOGICAL_AND: "&&"
LOGICAL_OR: "||"
LOGICAL_NOT: "!!"

// Assignment operators
ASSIGN: "="
STRONG_ASSIGN: "=*"
WEAK_ASSIGN: "=?"
SPREAD_ASSIGN: "..="
STRONG_SPREAD_ASSIGN: "..=*"
WEAK_SPREAD_ASSIGN: "..=?"

// Pipeline operators
PIPE: "|"
PIPELINE_FAILURE: "|?"
PIPELINE_BLOCK_START: "|{"
PIPELINE_MODIFIER: "|<<"
BLOCK_INVOKE: "|."

// Structure operators
DOT: "."
HASH: "#"
SPREAD: ".."
AMPERSAND: "&"
PRIVATE_ACCESS: "&."
BLOCK_START: ".{"
FALLBACK: "??"
PLACEHOLDER: "???"

// Scope operators
AT: "@"
DOLLAR: "$"
CARET: "^"

// === STRUCTURAL TOKENS ===
LBRACE: "{"
RBRACE: "}"
LBRACKET: "["
RBRACKET: "]"
LPAREN: "("
RPAREN: ")"
SINGLE_QUOTE: "'"

// === EXPRESSION HIERARCHY ===
// Follows Python's precedence model with Comp-specific extensions
// Lower precedence = higher in the hierarchy

// Top level: expressions (assignments only in specific contexts)
?expression: assignment_expr

// Assignment expressions (only in specific contexts, not general expressions)  
?assignment_expr: fallback_expr

// Fallback operators (??)
?fallback_expr: pipe_expr
             | fallback_expr FALLBACK pipe_expr -> fallback_operation

// Pipeline operators (|, |?, |<<)
?pipe_expr: or_expr
         | pipe_expr PIPE identifier function_argument+ -> pipeline_function_call_operation  
         | pipe_expr PIPE or_expr -> pipeline_operation
         | pipe_expr PIPELINE_FAILURE or_expr -> pipeline_failure_operation
         | pipe_expr PIPELINE_MODIFIER or_expr -> pipeline_modifier_operation
         | pipe_expr PIPELINE_BLOCK_START structure_field* RBRACE -> pipeline_struct_operation
         | pipe_expr BLOCK_INVOKE identifier -> pipeline_block_invoke_operation
         | pipe_expr BLOCK_INVOKE AT identifier -> pipeline_block_invoke_operation
         | pipe_expr BLOCK_INVOKE CARET identifier -> pipeline_block_invoke_operation
         | pipe_expr BLOCK_INVOKE AT index_reference -> pipeline_block_invoke_operation
         | pipe_expr BLOCK_INVOKE CARET index_reference -> pipeline_block_invoke_operation

// Logical OR (||)
?or_expr: and_expr
        | or_expr LOGICAL_OR and_expr -> binary_operation

// Logical AND (&&)
?and_expr: not_expr
         | and_expr LOGICAL_AND not_expr -> binary_operation

// Logical NOT (!!)
?not_expr: comparison
         | LOGICAL_NOT not_expr -> unary_operation

// Comparison operators (==, !=, <, >, <=, >=)
?comparison: arith_expr
           | comparison comp_op arith_expr -> binary_operation

!comp_op: EQUAL_EQUAL | NOT_EQUAL | LESS_THAN | LESS_EQUAL | GREATER_THAN | GREATER_EQUAL

// Arithmetic expressions (+, -, +-)
?arith_expr: term
           | arith_expr PLUS term -> binary_operation
           | arith_expr MINUS term -> binary_operation
           | arith_expr SUBTRACT term -> binary_operation

// Terms (*, /, %)
?term: factor
     | term MULTIPLY factor -> binary_operation
     | term DIVIDE factor -> binary_operation
     | term MODULO factor -> binary_operation

// Factors (unary +/-, **)
?factor: power
       | PLUS factor -> unary_operation
       | MINUS factor -> unary_operation

// Power (**) - right-associative
?power: atom_expr
      | atom_expr POWER factor -> binary_operation

// Atom expressions (member access, indexing, calls)
?atom_expr: atom
         | atom_expr DOT index_reference -> field_access_operation
         | atom_expr DOT identifier -> field_access_operation
         | atom_expr DOT string -> field_access_operation  
         | atom_expr DOT SINGLE_QUOTE expression SINGLE_QUOTE -> field_access_operation
         | atom_expr AMPERSAND atom -> private_attach_operation
         | atom_expr PRIVATE_ACCESS identifier -> private_access_operation
         | AT identifier -> field_access_operation          // @local-counter
         | CARET identifier -> field_access_operation       // ^timeout
         | DOLLAR identifier DOT field_path -> field_access_operation // $mod.child
         | AT identifier DOT field_path -> field_access_operation    // @ctx.child
         | CARET identifier DOT field_path -> field_access_operation  // ^ctx.child
         | AT index_reference -> field_access_operation   // @#4
         | CARET index_reference -> field_access_operation // ^#4
         | BLOCK_INVOKE identifier -> block_invoke_operation
         | BLOCK_INVOKE AT identifier -> block_invoke_operation
         | BLOCK_INVOKE CARET identifier -> block_invoke_operation
         | BLOCK_INVOKE AT index_reference -> block_invoke_operation
         | BLOCK_INVOKE CARET index_reference -> block_invoke_operation

// Atoms (primary expressions - highest precedence)
?atom: number 
     | string 
     | identifier -> field_access_operation
     | tag_reference 
     | shape_reference 
     | function_reference
     | scope_reference
     | index_reference
     | structure
     | placeholder
     | array_type
     | computed_field_name
     | LPAREN expression RPAREN

// === COMP-SPECIFIC CONSTRUCTS ===

// Index references: #0, #1, #42
index_reference: HASH INDEX_NUMBER

// Scope references: $ctx, @, ^, etc. 
scope_reference: DOLLAR identifier                           // $ctx, $mod, $in, $out, $arg (validated in transformer)
               | AT                                           // @ (standalone only)
               | CARET                                        // ^ (standalone only)

// Computed expressions: 'expression' - single-quoted expressions that evaluate to values
computed_field_name: SINGLE_QUOTE expression SINGLE_QUOTE

// Structures: {field=value, positional, ..spread}
structure: LBRACE structure_field* RBRACE

structure_field: spread_operation | assignment_field | positional_field

// Combined assignment rule that handles both scope and field assignments
assignment_field: assignment_target assignment_op fallback_expr

assignment_target: scope_target | field_target  

// Spread operations: ..expression (spreads the expression into the structure)
spread_operation: SPREAD expression

// Positional fields: just expressions (implied positional assignment, excludes assignments)
positional_field: fallback_expr

// Function arguments: only allow field assignments and non-identifier literals (no bare identifiers that could be pipe targets)  
function_argument: function_field_assignment | number | string | tag_reference | shape_reference

// Function field assignment: identifier = expr (but no pipelines in expr)  
function_field_assignment: field_target assignment_op or_expr

// Assignment targets
scope_target: AT field_reference                      // @local, @local.nested.field, @#1, @"field", @'computed'
            | AT                                      // @ (bare at scope)
            | DOLLAR identifier                       // $out, $out.nested.field, $#1
            | DOLLAR identifier DOT field_reference   // $out, $out.nested.field, $#1
            | CARET field_reference                   // ^timeout, ^timeout.nested.field, ^#1
            | CARET                                   // ^ (bare caret scope)

// Field reference: unified rule for any field reference pattern
field_reference: identifier                           // field
               | identifier DOT field_path             // field.nested.path  
               | string                               // "string-field-name"
               | field_name                           // 'quoted-identifier'
               | computed_field_name                  // 'computed-expression'
               | index_reference                      // #1, #42 (indexed fields)

field_target: field_reference

field_path: identifier (DOT identifier)*

// Assignment operators
assignment_op: ASSIGN | STRONG_ASSIGN | WEAK_ASSIGN | SPREAD_ASSIGN | WEAK_SPREAD_ASSIGN | STRONG_SPREAD_ASSIGN

// Placeholders: ???
placeholder: PLACEHOLDER

// Array types: identifier[]
array_type: identifier LBRACKET RBRACKET

// Field names: 'identifier' - quoted field names for meta-programming
field_name: SINGLE_QUOTE identifier SINGLE_QUOTE

// === FUTURE EXTENSIONS ===
// Reserved space for upcoming language features:
// - Pattern matching constructs
// - Module/import expressions  
// - Unit type annotations
// - Generic type parameters
// - Trait/protocol definitions
// - Async/await expressions
// - Resource/capability tokens