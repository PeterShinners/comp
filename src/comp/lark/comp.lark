// Comp Language Grammar v2 - Clean Restart
//
// Starting from the ground up with just literals and identifiers.
// Focus on simplicity and letting the grammar do the work, not the transformer.
//
// DESIGN PRINCIPLES:
// - Grammar rules should be self-explanatory
// - Minimize transformer complexity
// - Clear separation of concerns
// - Declarative over imperative

// === ENTRY POINTS ===

// Module-level parsing (default - for complete .comp files)
start: module

// Module contains zero or more module-level statements
module: module_statement*

// Module-level statements (definitions and top-level expressions)
?module_statement: tag_definition
                 | shape_definition
                 | function_definition
                 | expression         // Allow expressions for REPL/testing compatibility

// Expression-level parsing (for REPL, testing, embedded evaluation)
// Access via Lark's start parameter: Lark(..., start="expression_start")
expression_start: expression

// === BASIC TOKENS ===

// Comments
COMMENT: /;[^\r\n]*/
%ignore COMMENT
%ignore /\s+/

// === NUMBER LITERALS ===
// Identifies integer only values with bases, which need different parsing
// route. Allow underscores for readability. 
// Leading signs are handled by unary operators

number: INTBASE | DECIMAL

// Based number formats - unsigned, signs handled by unary operators
INTBASE.2: /0[xXbBoO](_?[\da-zA-Z])+/                      // All bases: hex, binary, octal

// Decimal formats - unsigned, signs handled by unary operators  
DECIMAL.1: /(([1-9](_?\d)*)|0(_?0)*)/                      // Integer: 123, 1_000, 0, 0_0 
         | /\d(_?\d)*\.(\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?/  // Decimal: 3.14, 5., 1.5e-10, 5.e10
         | /\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?/              // Leading dot: .5, .123_456, .5e10  
         | /\d(_?\d)*[eE][+-]?\d(_?\d)*/                   // Scientific integer: 1e5, 1_000e10


// === STRING LITERALS ===
// String parsing with separated quotes and content.
// Uses Python's regex patterns but separates quotes from content in parse tree.
DUBQUOTE: "\""
SIXQUOTE:  "\"\"\""
SHORT_STRING_CONTENT: /(?:[^"\\\r\n]|\\.)+/i
_short_string: DUBQUOTE SHORT_STRING_CONTENT? DUBQUOTE

LONG_STRING_CONTENT: /(.|\n)+?(?=""")/is
_long_string: SIXQUOTE LONG_STRING_CONTENT? SIXQUOTE

string: _short_string | _long_string

// === IDENTIFIER FIELDS ===

// The simplest name token for an identifier, UAX #31 compliant
// Allows dashes and single optional trailing question mark
TOKEN: /[^\W\d][\w-]*[?]?/
INDEXFIELD: /#\d+/

// Individual field types - explicit rules for each context
tokenfield: TOKEN
indexfield: INDEXFIELD
stringfield: string
computefield: "'" expression "'"

// Scope field types
localscope: "@"
argscope: "^"
namescope: "$" TOKEN

// Field components that can appear in identifiers
// First field in a chain (cannot be a string literal - that would be standalone)
?identifier_first_field: tokenfield | indexfield | computefield

// Fields after a dot (can include strings for quoted field names like obj."field")
?identifier_next_field: tokenfield | indexfield | string | computefield

// Identifier can optionally start with a scope marker
// Examples: foo.bar, @foo.bar, ^item, $mod.pizza
// Bare scope markers are also identifiers: @, ^, $mod
identifier: localscope identifier_first_field ("." identifier_next_field)*  // @foo.bar
          | argscope identifier_first_field ("." identifier_next_field)*    // ^foo.bar
          | namescope ("." identifier_next_field)*                          // $mod.pizza
          | localscope                                                      // @
          | argscope                                                        // ^
          | namescope                                                       // $mod
          | identifier_first_field ("." identifier_next_field)*             // foo.bar

_qualified: identifier


// === REFERENCE LITERALS ===
// References to tags, shapes, and functions. Possibly from other namespaces.
reference_identifiers: TOKEN ("." TOKEN)*
reference_namespace: "/" TOKEN?
_reference_path:  reference_identifiers reference_namespace?
tag_reference: "#" _reference_path
shape_reference: "~" _reference_path  
function_reference: "|" _reference_path
_function_piped: "|" _reference_path  // ignored for pipeline parsing


// === MODULE-LEVEL DEFINITIONS ===

// Tag definitions (!tag)
// Supports multiple styles:
//   Simple:     !tag #status
//   Nested:     !tag #status = {#active #inactive}
//   Flat:       !tag #status.error.timeout
//   Hierarchical: !tag #status = {#error = {#timeout #network}}
// Note: Tag definitions cannot include module namespace (no /module suffix)
BANG_TAG: "!tag"

tag_definition: BANG_TAG tag_path                                              // Simple: !tag #status
              | BANG_TAG tag_path tag_generator ASSIGN tag_value tag_body        // With generator, value, and children
              | BANG_TAG tag_path tag_generator ASSIGN tag_value                 // With generator and value: !tag #status |gen = 42
              | BANG_TAG tag_path tag_generator ASSIGN tag_body                  // With generator and children: !tag #color |name/tag = {#red #green}
              | BANG_TAG tag_path ASSIGN tag_value tag_body                      // With value and children: !tag #status = 42 {#active}
              | BANG_TAG tag_path ASSIGN tag_value                               // With value: !tag #status = 42
              | BANG_TAG tag_path ASSIGN tag_body                                // With children: !tag #status = {#active #inactive}

tag_path: "#" reference_identifiers                       // Tag path without namespace

tag_generator: function_reference | block                 // Generator function or inline block

tag_body: LBRACE tag_child* RBRACE                        // {children...}

tag_child: tag_path                                       // Simple child: #active
         | tag_path ASSIGN tag_value tag_body             // Child with value and children: #active = 1 {#sub}
         | tag_path ASSIGN tag_value                      // Child with value: #active = 1
         | tag_path ASSIGN tag_body                       // Child with children: #error = {#timeout}

// Tag values are build-time constant expressions without structures/blocks
// Supports: literals (42, "text"), references (#tag, ~shape), arithmetic (1+2, 1<<3), etc.
tag_value: tag_arithmetic

?tag_arithmetic: tag_term
               | tag_arithmetic "+" tag_term   -> binary_op
               | tag_arithmetic "-" tag_term   -> binary_op

?tag_term: tag_bitwise
         | tag_term "*" tag_bitwise   -> binary_op
         | tag_term "/" tag_bitwise   -> binary_op

?tag_bitwise: tag_comparison
            | tag_bitwise "<<" tag_comparison    -> binary_op
            | tag_bitwise ">>" tag_comparison    -> binary_op
            | tag_bitwise "&" tag_comparison     -> binary_op
            | tag_bitwise "|" tag_comparison     -> binary_op
            | tag_bitwise "^" tag_comparison     -> binary_op

?tag_comparison: tag_unary
               | tag_comparison "<" tag_unary   -> binary_op
               | tag_comparison ">" tag_unary   -> binary_op
               | tag_comparison "<=" tag_unary  -> binary_op
               | tag_comparison ">=" tag_unary  -> binary_op
               | tag_comparison "==" tag_unary  -> binary_op
               | tag_comparison "!=" tag_unary  -> binary_op

?tag_unary: tag_atom
          | "+" tag_unary  -> unary_op
          | "-" tag_unary  -> unary_op
          | "!" tag_unary  -> unary_op

// Atoms allowed in tag values - excludes structure, block, pipeline
?tag_atom: number
         | string
         | _qualified          // References: #tag, ~shape, |func, @local, $placeholder
         | paren_expr          // Parenthesized expressions


// === SHAPE DEFINITIONS ===

// Shape definitions (!shape)
// Supports simple and complex shapes:
//   Simple:     !shape ~point = {x ~num y ~num}
//   Defaults:   !shape ~point = {x ~num = 0 y ~num = 0}
//   Optional:   !shape ~user = {name ~str email? ~str}
//   Nested:     !shape ~circle = {pos ~{x ~num y ~num} radius ~num}
//   Spread:     !shape ~point3d = {..~point z ~num}
//   Union:      !shape ~result = ~success | ~error
// Note: Shape definitions cannot include module namespace (no /module suffix)
BANG_SHAPE: "!shape"

shape_definition: BANG_SHAPE shape_path ASSIGN shape_body

shape_path: "~" reference_identifiers                     // Shape path without namespace

shape_body: LBRACE shape_field* RBRACE                    // Shape with fields
          | shape_type (ASSIGN expression)?               // Alias or union, optionally with default

?shape_field: shape_spread                                // ..~shape (spread)
            | shape_field_def                             // field? ~type = default

shape_field_def: TOKEN QUESTION? shape_type? (ASSIGN expression)?  // Named field
               | shape_type (ASSIGN expression)?          // Positional field (no name)

shape_spread: SPREAD shape_type                           // ..~shape

// Union is now a separate rule that creates a flat list
shape_union: shape_type_atom (PIPE shape_type_atom)+      // ~type1 | ~type2 | ~type3

// Renamed to shape_type_atom - individual type without union
shape_type_atom: shape_reference                          // ~typename
               | tag_reference                            // #tagname (tag as type)
               | shape_inline                             // ~{...} inline shape

// Inline anonymous shape definition
shape_inline: TILDE LBRACE shape_field* RBRACE            // ~{fields...}

// shape_type can be a union or a single atom
shape_type: shape_union | shape_type_atom

TILDE: "~"
HASH: "#"
PIPE: "|"
QUESTION: "?"


// === FUNCTION DEFINITION ===
BANG_FUNC: "!func"

function_definition: BANG_FUNC function_path function_shape arg_shape _assignment_op structure
                   | BANG_FUNC function_path function_shape _assignment_op structure

function_path: PIPE TOKEN ("." TOKEN)*

function_shape: shape_type

arg_shape: CARET shape_body

CARET: "^"


// === STRUCTURE DEFINITION ===
LBRACE: "{"
RBRACE: "}"
LBRACKET: "["
RBRACKET: "]"
COLON_BLOCK_START: ":{"
SPREAD: ".."
structure: LBRACE _structure_content RBRACE
block: COLON_BLOCK_START _structure_content RBRACE
_structure_content: structure_op*
?structure_op: structure_spread | structure_assign | structure_unnamed
structure_spread: SPREAD expression
structure_assign: _qualified _assignment_op expression  
structure_unnamed: expression


// === ASSIGN EXPRESSIONS ===
// Assignments are not part of basic expressions, they are handled at specific
// points in the grammar
ASSIGN: "="
STRONG_ASSIGN: "=*"
WEAK_ASSIGN: "=?"
SPREAD_ASSIGN: "..="
STRONG_SPREAD_ASSIGN: "..=*"
WEAK_SPREAD_ASSIGN: "..=?"
_assignment_op: ASSIGN | STRONG_ASSIGN | WEAK_ASSIGN | SPREAD_ASSIGN | WEAK_SPREAD_ASSIGN | STRONG_SPREAD_ASSIGN


// === BASIC ATOM ===

// Atoms: the basic building blocks
LPAREN: "("
RPAREN: ")"
PLACEHOLDER: "???"
placeholder: PLACEHOLDER

// Parenthesized expressions - simple grouping only (no pipelines)
?paren_expr: LPAREN expression RPAREN

// Pipeline expressions - now use square brackets
pipeline_expr: LBRACKET pipeline RBRACKET
             | LBRACKET _prepipeline_expression pipeline RBRACKET  // Seeded pipeline

// Atoms only match single entities
// String is an atom (standalone literal), but can also appear as a field via stringfield
?atom: number
     | string
     | _qualified
     | tag_reference
     | structure
     | block
     | placeholder
     | paren_expr
     | pipeline_expr


// Entry to the expression grammar
?expression: _prepipeline_expression

// === PIPELINE EXPRESSIONS ===
// Pipelines now use square brackets: [seed |op1 |op2] or [|op]
// PIPE_FUNC: "|"
PIPE_FALLBACK: "|?"
PIPE_STRUCT: "|{"
PIPE_WRENCH: "|-|"
PIPE_BLOCK: "|:"
pipe_func: function_reference function_arguments
pipe_struct: PIPE_STRUCT structure_op* RBRACE
pipe_fallback: PIPE_FALLBACK expression
pipe_block: PIPE_BLOCK _qualified
pipe_wrench: PIPE_WRENCH _function_piped
pipeline: (pipe_func | pipe_struct | pipe_block | pipe_wrench | pipe_fallback)+

function_arguments: structure_op*

// === BASIC EXPRESSIONS ===

// Expression level that excludes pipelines - used for function arguments 
// and other contexts where pipelines should not be parsed
_prepipeline_expression: or_expr

// Boolean operators
LOGICAL_AND: "&&"
LOGICAL_OR: "||"
LOGICAL_NOT: "!!"
?or_expr: and_expr | or_expr LOGICAL_OR and_expr -> binary_op
?and_expr: not_expr | and_expr LOGICAL_AND not_expr -> binary_op
?not_expr: comparison | LOGICAL_NOT not_expr -> unary_op

// Comparison operators
EQUAL_EQUAL: "=="
NOT_EQUAL: "!="
LESS_THAN: "<"
LESS_EQUAL: "<="
GREATER_THAN: ">"
GREATER_EQUAL: ">="
?comp_op: EQUAL_EQUAL | NOT_EQUAL | LESS_THAN | LESS_EQUAL | GREATER_THAN | GREATER_EQUAL
?comparison: morph_expr | comparison comp_op morph_expr -> binary_op

// Shape morph operators
// Transforms data to match a shape specification
// Normal (~): apply defaults, allow extra fields
// Strong (~*): no extra fields allowed, strict matching
// Weak (~?): missing fields acceptable, partial matching
STRONG_MORPH: "~*"
WEAK_MORPH: "~?"

// Shape type in morph context
// Accepts both bare identifiers (cat | dog) and full references (~cat | ~dog)
?morph_type: reference_identifiers reference_namespace?   // shapename or module.shape
           | tag_reference                                // #tag
           | shape_reference                              // ~shapename (full syntax)
           | shape_inline                                 // ~{...}
           | morph_inline                                 // {...} (without ~)
           | morph_union                                  // cat | dog or ~cat | ~dog

// Inline shape without leading ~ for morph context
morph_inline: LBRACE shape_field* RBRACE

morph_union: morph_type (PIPE morph_type)+

?morph_expr: arith_expr
           | morph_expr "~" morph_type -> morph_op
           | morph_expr STRONG_MORPH morph_type -> strong_morph_op
           | morph_expr WEAK_MORPH morph_type -> weak_morph_op

// Number operators 
PLUS: "+"
MINUS: "-"
KEBAB_MINUS: "+-"  // Disambiguation for subtraction vs kebab-case identifiers
MULTIPLY: "*"
DIVIDE: "/"
MODULO: "%"
POWER: "**"
?arith_expr: term  // Arith (+, -, +-)
           | arith_expr PLUS term -> binary_op
           | arith_expr MINUS term -> binary_op
           | arith_expr KEBAB_MINUS term -> binary_op
?term: unary  // Terms (*, /, %)
     | term MULTIPLY unary -> binary_op
     | term DIVIDE unary -> binary_op
     | term MODULO unary -> binary_op
?unary: power  // Factors (unary +/-)
       | PLUS unary -> unary_op
       | MINUS unary -> unary_op
?power: atom_in_expr  // Power (**) - right-associative  
      | atom_in_expr POWER unary -> binary_op


// === ATOM EXPRESSIONS ===
// Use of atoms to continue building expressions
FALLBACK: "??"
?atom_in_expr: atom
             | atom_in_expr "." identifier_next_field -> atom_field
             | atom_in_expr FALLBACK expression -> atom_fallback
//          //  | atom_in_expr PRIVATEATTACH -> atom_private
//          //  | atom_in_expr PRIVATEFIELD identifier -> atom_private_field

