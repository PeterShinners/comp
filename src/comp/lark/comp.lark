// Comp Language Grammar v2 - Clean Restart
//
// Starting from the ground up with just literals and identifiers.
// Focus on simplicity and letting the grammar do the work, not the transformer.
//
// DESIGN PRINCIPLES:
// - Grammar rules should be self-explanatory
// - Minimize transformer complexity
// - Clear separation of concerns
// - Declarative over imperative

// === ENTRY POINT ===
start: expression

// === BASIC TOKENS ===

// Comments
COMMENT: /;[^\r\n]*/
%ignore COMMENT
%ignore /\s+/

// === NUMBER LITERALS ===
// Identifies integer only values with bases, which need different parsing
// route. Allow underscores for readability. 
// Leading signs are handled by unary operators

number: INTBASE | DECIMAL

// Based number formats - unsigned, signs handled by unary operators
INTBASE.2: /0[xXbBoO](_?[\da-zA-Z])+/                      // All bases: hex, binary, octal

// Decimal formats - unsigned, signs handled by unary operators  
DECIMAL.1: /(([1-9](_?\d)*)|0(_?0)*)/                      // Integer: 123, 1_000, 0, 0_0 
         | /\d(_?\d)*\.(\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?/  // Decimal: 3.14, 5., 1.5e-10, 5.e10
         | /\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?/              // Leading dot: .5, .123_456, .5e10  
         | /\d(_?\d)*[eE][+-]?\d(_?\d)*/                   // Scientific integer: 1e5, 1_000e10


// === STRING LITERALS ===
// String parsing with separated quotes and content.
// Uses Python's regex patterns but separates quotes from content in parse tree.
DUBQUOTE: "\""
SIXQUOTE:  "\"\"\""
SHORT_STRING_CONTENT: /[^"\\\r\n]+(?:\\.[^"\\\r\n]*)*/i
_short_string: DUBQUOTE SHORT_STRING_CONTENT? DUBQUOTE

LONG_STRING_CONTENT: /(.|\n)+?(?=""")/is
_long_string: SIXQUOTE LONG_STRING_CONTENT? SIXQUOTE

string: _short_string | _long_string

// === TOKEN ===

// The simplest name token for an identifier, UAX #31 compliant
// Allows dashes and single optional trailing question mark
TOKEN: /[^\W\d][\w-]*[?]?/
INDEXFIELD: /#\d+/
computefield: "'" expression "'"
field_name: "'" TOKEN "'"


// individual component of an identifier
?field_leader: TOKEN | INDEXFIELD | computefield
?field_follower: field_leader | string | field_name
identifier: field_leader ("." field_follower)*

LOCALSCOPE: "@"
ARGSCOPE: "^"
NAMESCOPE: "$" TOKEN

scope: LOCALSCOPE
     | LOCALSCOPE field_follower
     | ARGSCOPE
     | ARGSCOPE field_follower
     | NAMESCOPE
     | NAMESCOPE "." field_follower


_qualified: scope | identifier


// === REFERENCE LITERALS ===
// References to tags, shapes, and functions. Possibly from other namespaces.
reference_identifiers: TOKEN ("." TOKEN)*
reference_namespace: "/" TOKEN?
_reference_path:  reference_identifiers reference_namespace?
tag_reference: "#" _reference_path
shape_reference: "~" _reference_path  
function_reference: "|" _reference_path
_function_piped: "|" _reference_path  // ignored for pipeline parsing


// === STRUCTURE DEFINITION ===
LBRACE: "{"
RBRACE: "}"
COLON_BLOCK_START: ":{"
SPREAD: ".."
structure: LBRACE _structure_content RBRACE
block: COLON_BLOCK_START _structure_content RBRACE
_structure_content: structure_op* | pipeline
?structure_op: structure_spread | structure_assign | structure_unnamed
structure_spread: SPREAD expression
structure_assign: _qualified _assignment_op expression  
structure_unnamed: expression


// === ASSIGN EXPRESSIONS ===
// Assignments are not part of basic expressions, they are handled at specific
// points in the grammar
ASSIGN: "="
STRONG_ASSIGN: "=*"
WEAK_ASSIGN: "=?"
SPREAD_ASSIGN: "..="
STRONG_SPREAD_ASSIGN: "..=*"
WEAK_SPREAD_ASSIGN: "..=?"
_assignment_op: ASSIGN | STRONG_ASSIGN | WEAK_ASSIGN | SPREAD_ASSIGN | WEAK_SPREAD_ASSIGN | STRONG_SPREAD_ASSIGN


// === BASIC ATOM ===

// Atoms: the basic building blocks
LPAREN: "("
RPAREN: ")"
PLACEHOLDER: "???"
placeholder: PLACEHOLDER

// Parenthesized expressions - keeps atom definition flatter
?paren_expr: LPAREN expression RPAREN
           | LPAREN pipeline RPAREN

// Atoms only match single entities
?atom: number
     | string
     | _qualified
     | tag_reference
     | structure
     | block
     | placeholder
     | field_name
     | paren_expr


// Entry to the expression grammar
?expression: _prepipeline_expression
           | _prepipeline_expression pipeline -> expr_pipeline

// === PIPELINE EXPRESSIONS ===
// PIPE_FUNC: "|"
PIPE_FALLBACK: "|?"
PIPE_STRUCT: "|{"
PIPE_WRENCH: "|<<"
PIPE_BLOCK: "|:"
pipe_func: _function_piped function_arguments
pipe_struct: PIPE_STRUCT structure_op* RBRACE
pipe_fallback: PIPE_FALLBACK expression
pipe_block: PIPE_BLOCK _qualified
pipe_wrench: PIPE_WRENCH _function_piped  // Not right, may want to be a block or struct?
pipeline: (pipe_func | pipe_struct | pipe_block | pipe_wrench | pipe_fallback)+

function_arguments: functionstructure_op*
?functionstructure_op: function_structure_spread | function_structure_assign | function_structure_unnamed
function_structure_spread: SPREAD _prepipeline_expression
function_structure_assign: _qualified _assignment_op _prepipeline_expression  
function_structure_unnamed: _prepipeline_expression

// === BASIC EXPRESSIONS ===

// Expression level that excludes pipelines - used for function arguments 
// and other contexts where pipelines should not be parsed
_prepipeline_expression: or_expr

// Boolean operators
LOGICAL_AND: "&&"
LOGICAL_OR: "||"
LOGICAL_NOT: "!!"
?or_expr: and_expr | or_expr LOGICAL_OR and_expr -> binary_op
?and_expr: not_expr | and_expr LOGICAL_AND not_expr -> binary_op
?not_expr: comparison | LOGICAL_NOT not_expr -> unary_op

// Comparison operators
EQUAL_EQUAL: "=="
NOT_EQUAL: "!="
LESS_THAN: "<"
LESS_EQUAL: "<="
GREATER_THAN: ">"
GREATER_EQUAL: ">="
!comp_op: EQUAL_EQUAL | NOT_EQUAL | LESS_THAN | LESS_EQUAL | GREATER_THAN | GREATER_EQUAL
?comparison: arith_expr | comparison comp_op arith_expr -> binary_op

// Number operators 
PLUS: "+"
MINUS: "-"
KEBAB_MINUS: "+-"  // Disambiguation for subtraction vs kebab-case identifiers
MULTIPLY: "*"
DIVIDE: "/"
MODULO: "%"
POWER: "**"
?arith_expr: term  // Arith (+, -, +-)
           | arith_expr PLUS term -> binary_op
           | arith_expr MINUS term -> binary_op
           | arith_expr KEBAB_MINUS term -> binary_op
?term: unary  // Terms (*, /, %)
     | term MULTIPLY unary -> binary_op
     | term DIVIDE unary -> binary_op
     | term MODULO unary -> binary_op
?unary: power  // Factors (unary +/-)
       | PLUS unary -> unary_op
       | MINUS unary -> unary_op
?power: atom_in_expr  // Power (**) - right-associative  
      | atom_in_expr POWER unary -> binary_op


// === ATOM EXPRESSIONS ===
// Use of atoms to continue building expressions
// PRIVATEATTACH: "&"
// PRIVATEFIELD: "&."
FALLBACK: "??"
?atom_in_expr: atom
             | atom_in_expr "." field_follower -> atom_field
             | atom_in_expr "??" expression -> atom_fallback
//          //  | atom_in_expr PRIVATEATTACH -> atom_private
//          //  | atom_in_expr PRIVATEFIELD identifier -> atom_private_field

