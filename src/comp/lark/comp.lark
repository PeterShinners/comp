// Comp Language Grammar - Main Entry Point
//
// Uses uni// Start rule
start: expression

// Unified expression hierarchy (following Python's pattern with Comp extensions)
// Assignment is NOT a general expression - it only occurs in specific contexts like structures
?expression: fallback_expr

// Fallback operators (Comp-specific)
?fallback_expr: pipe_expr
             | fallback_expr FALLBACK pipe_expr -> fallback_operation

// Pipe/union operators (Comp-specific)
?pipe_expr: or_expr
         | pipe_expr PIPE or_expr -> shape_union_operation
         | pipe_expr PIPELINE_FAILURE or_expr -> pipeline_failure_operation

// Logical OR (like Python)
?or_expr: and_expr
        | or_expr LOGICAL_OR and_expr -> binary_operation

// Logical AND (like Python)
?and_expr: not_expr
         | and_expr LOGICAL_AND not_expr -> binary_operation

// Logical NOT (like Python)
?not_expr: comparison
         | LOGICAL_NOT not_expr -> unary_operation

// Comparisons (like Python)
?comparison: arith_expr
           | comparison comp_op arith_expr -> binary_operation

!comp_op: EQUAL_EQUAL | NOT_EQUAL | LESS_THAN | LESS_EQUAL | GREATER_THAN | GREATER_EQUAL

// Arithmetic expressions (like Python)
?arith_expr: term
           | arith_expr PLUS term -> binary_operation
           | arith_expr MINUS term -> binary_operation

// Terms (multiplication, division, modulo)
?term: factor
     | term MULTIPLY factor -> binary_operation
     | term DIVIDE factor -> binary_operation
     | term MODULO factor -> binary_operation

// Factors (unary +/-, power)
?factor: power
       | PLUS factor -> unary_operation
       | MINUS factor -> unary_operation

// Power (right-associative, like Python)
?power: atom_expr
      | atom_expr POWER factor -> binary_operation

// Atom expressions (member access, indexing, calls - like Python)
?atom_expr: atom
         | atom_expr DOT identifier -> field_access_operation
         | atom_expr HASH arith_expr -> index_access_operation
         | atom_expr AMPERSAND atom -> private_attach_operation
         | atom_expr PRIVATE_ACCESS identifier -> private_access_operation
         | BLOCK_INVOKE identifier -> block_invoke_operation

// Atoms (primary expressions - like Python)
?atom: number 
     | string 
     | identifier 
     | tag_reference 
     | shape_reference 
     | function_reference
     | index_reference
     | structure
     | block_definition
     | placeholder
     | array_type
     | field_name
     | LPAREN expression RPAREN

// Comp-specific constructs
index_reference: HASH arith_expr

structure: LBRACE structure_field* RBRACE

structure_field: named_field | positional_field | spread_field

named_field: identifier assignment_op expression

assignment_op: ASSIGN | WEAK_ASSIGN | STRONG_ASSIGN | SPREAD_ASSIGN | WEAK_SPREAD_ASSIGN | STRONG_SPREAD_ASSIGN

positional_field: expression

spread_field: SPREAD expression

block_definition: BLOCK_START expression RBRACE

placeholder: PLACEHOLDER

array_type: identifier LBRACKET RBRACKET

field_name: SINGLE_QUOTE identifier SINGLE_QUOTE

// Import basic building blocks
%import numbers (BASED, DECIMAL, number)
%import strings (BASIC_STRING, string)
%import identifiers (IDENTIFIER, identifier)
%import references (TAG_REFERENCE, SHAPE_REFERENCE, FUNCTION_REFERENCE, tag_reference, shape_reference, function_reference)

// All operators (both mathematical and advanced)
// Mathematical operators
PLUS: "+"
MINUS: "-"
MULTIPLY: "*"
DIVIDE: "/"
MODULO: "%"
POWER: "**"
EQUAL_EQUAL: "=="
NOT_EQUAL: "!="
LESS_THAN: "<"
LESS_EQUAL: "<="
GREATER_THAN: ">"
GREATER_EQUAL: ">="
LOGICAL_AND: "&&"
LOGICAL_OR: "||"
LOGICAL_NOT: "!"

// Assignment operators
ASSIGN: "="
WEAK_ASSIGN: "?="
STRONG_ASSIGN: "*="
SPREAD_ASSIGN: "..="
WEAK_SPREAD_ASSIGN: "?..="
STRONG_SPREAD_ASSIGN: "*..="

// Advanced operators
DOT: "."
HASH: "#"
SPREAD: ".."
AMPERSAND: "&"
PRIVATE_ACCESS: "&."
PIPE: "|"
PIPELINE_FAILURE: "|?"
PIPELINE_BLOCK_START: "|{"
BLOCK_START: ".{"
BLOCK_INVOKE: "|."
FALLBACK: "??"
PLACEHOLDER: "???"

// Structural tokens
LBRACE: "{"
RBRACE: "}"
LBRACKET: "["
RBRACKET: "]"
LPAREN: "("
RPAREN: ")"
SINGLE_QUOTE: "'"

// Whitespace handling  
%import common.WS
%ignore WS