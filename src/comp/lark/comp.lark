// Comp Language Grammar

start: module*

?module: import_stmt
       | mod_field
       | expression

import_stmt: KEY_IMPORT simple_name structure
simple_name: TOKENFIELD
mod_field: identifier ASSIGN expression


PAREN_OPEN.6: "("
PAREN_CLOSE.6: ")"
ASSIGN.7: "="
COLON.4: ":"

// Shape
TILDE.4: "~"
COMMA.4: ","
shape: TILDE shape_spec
shape_spec: (identifier | paren_shape) guard_suffix? array_suffix?
GUARD_OPEN.4: "["
GUARD_CLOSE.4: "]"
ARRAY_OPEN.4: "{"
ARRAY_CLOSE.4: "}"
guard_suffix: GUARD_OPEN struct_field+ GUARD_CLOSE
array_suffix: ARRAY_OPEN (number (COMMA number?)?)? ARRAY_CLOSE
paren_shape: PAREN_OPEN shape_content PAREN_CLOSE

shape_content: shape_union | shape_field*
shape_union: shape_spec (PIPE shape_spec)+
shape_field: (TOKENFIELD | shape | TOKENFIELD shape) (ASSIGN field_default_value)?
?field_default_value: simple_expr | structure


// Keywords (having custom syntaxes)
// Priority 8 to be higher than BANG (7)
KEY_IMPORT.8: "!import"
KEY_TRANSACT.8: "!transact"
KEY_GRAB.8: "!grab"
KEY_DROP.8: "!drop"
KEY_PUSH.8: "!push"
KEY_PULL.8: "!pull"
transaction: KEY_TRANSACT PAREN_OPEN identifier+ PAREN_CLOSE

?expression: comparison
           | transaction


// Expressions
EQ.6: "=="
NE.6: "!="
LT.6: "<"
GT.6: ">"
LE.6: "<="
GE.6: ">="

PIPE.4: "|"
PIPEFALLBACK.4: "|?"

BANG.7: "!"
LNOT.5: "!!"
LAND.5: "&&"
LOR.5: "||"

PLUS.3: "+"
MINUS.3: "-"
KEBAB_MINUS.3: "+-"
STAR.3: "*"
SLASH.3: "/"

?comparison: arithmetic
           | comparison EQ arithmetic -> compare_op
           | comparison NE arithmetic -> compare_op
           | comparison LT arithmetic -> compare_op
           | comparison GT arithmetic -> compare_op
           | comparison LE arithmetic -> compare_op
           | comparison GE arithmetic -> compare_op

?arithmetic: term
           | arithmetic (PLUS | MINUS | KEBAB_MINUS) term -> binary_op

?term: pipeline_expr
     | term (STAR | SLASH) pipeline_expr -> binary_op

?pipeline_expr: unary
              | unary ((PIPE | PIPEFALLBACK) unary)+ -> pipeline

?unary: postfix
      | (PLUS | MINUS | LNOT) unary -> unary_op

?postfix: atom
        | atom DOT identifier -> postidentifier

// Simplified expressions, for default values  (avoids ambiguity) 
?simple_expr: simple_term
             | simple_expr (PLUS | MINUS | KEBAB_MINUS | LAND | LOR) simple_term -> binary_op
?simple_term: simple_atom
            | simple_term (STAR | SLASH) simple_atom -> binary_op
?simple_atom: number | text | identifier
             | (PLUS | MINUS | LNOT) simple_atom -> unary_op


// Structures and Blocks
KEY_LET.8: "!let"
block: COLON shape_field* structure
structure: PAREN_OPEN struct_decorator* (let_assign|struct_field)* PAREN_CLOSE
struct_decorator: PIPE identifier
let_assign: KEY_LET identifier ASSIGN expression
struct_field: (identifier ASSIGN)? expression


// Identifiers and atoms
DOT.6: "."
HASH: "#"
ONEQUOTE.7: "'"
TOKENFIELD.4: /[a-zA-Z_][\w-]*(?!\.\d)/  //negative lookahead prevents matching sibling numbers without space
indexfield: HASH INTEGER
indexprfield: HASH PAREN_OPEN simple_expr PAREN_CLOSE
exprfield: ONEQUOTE expression ONEQUOTE
?firstfield: TOKENFIELD -> tokenfield | exprfield
?nextfield: firstfield | indexfield | indexprfield | text -> textfield
identifier: firstfield (DOT nextfield)*

invoke: (text | identifier | number | block | invoke) (structure block* | block+)


?atom: number
     | text
     | identifier
     | structure
     | block
     | shape
     | invoke
     // | atom (structure block* | block+) -> invokex


// Comments completely ignored in the full grammar parse. They are
// captured in the scan.lark prepass.
DOC_COMMENT.8: /---(.|\n)*?---/s
LINE_COMMENT.8: /--[^\r\n]*/

%import .common (text, number, INTEGER, WS)
%ignore WS
%ignore LINE_COMMENT
%ignore DOC_COMMENT
