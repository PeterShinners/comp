// Comp Language Grammar
// Entry points for statement-by-statement parsing

// ===== MODULE STATEMENT ENTRY POINTS =====
// Each entry point parses the body of a module-level statement
// The operator name is already extracted by the scanner

start_package: text                                    // !package name "value"
start_import: identifier text                          // !import compiler "source"
start_mod: expression                                  // !mod name value (allow structures)
start_shape: shape                                     // !shape name ~spec
start_func: func_body  // !func name [~type] [@wrapper] body
func_body: shape wrapper* func_struct
         | wrapper+ func_struct
         | func_struct
func_struct: statement | structure
start_startup: startup_body  // !startup name [@wrapper] body
startup_body: wrapper+ func_struct
            | func_struct
start_tag: (BRACE_OPEN tag_item* BRACE_CLOSE)?        // !tag name {items}
tag_item: identifier (BRACE_OPEN tag_item* BRACE_CLOSE)?


// ===== BASIC DELIMITERS =====
// Highest priority to prevent text content from swallowing delimiters
PAREN_OPEN.9: "("
PAREN_CLOSE.9: ")"
BRACE_OPEN.9: "{"
BRACE_CLOSE.9: "}"
BRACKET_OPEN.9: "["
BRACKET_CLOSE.9: "]"
ANGLE_OPEN.9: "<"
ANGLE_CLOSE.9: ">"


// ===== OPERATORS & PUNCTUATION =====
// Higher priority than text content to prevent TEXT_CONTENT from matching operators
EQUALS.5: "="
COLON.5: ":"
TILDE.5: "~"
DOT.5: "."
PIPE.5: "|"
HASH.5: "#"
DOLLAR3.6: "$$$"
DOLLAR2.6: "$$"
DOLLAR.5: "$"
AT.5: "@"

// Comparison operators
// Note: >= and <= are NOT defined as single tokens
// Instead, they are parsed as ANGLE_CLOSE + EQUALS or ANGLE_OPEN + EQUALS
// This allows shape syntax like ~num<min=1>=2 to parse correctly without spaces
// The parser recombines adjacent > + = into >= and < + = into <=
// See lark_to_cop compare_op case for the merge logic
EQ.10: "=="
NE.10: "!="
CMP.10: "<>"

// Logical operators
LNOT.6: "!!"
LAND.6: "&&"
LOR.6: "||"

// Arithmetic operators
PLUS.6: "+"
MINUS.6: "-"
KEBAB_MINUS.6: "+-"
STAR.6: "*"
SLASH.6: "/"

// Pipeline operators
PIPEFALLBACK.6: "|?"

// Field expression delimiter
QUOTE.6: "'"


// ===== KEYWORDS & OPERATORS =====
// Statement operators (high priority to match before standalone !)
OP_LET.7: "!let"
OP_TRANSACT.7: "!transact"
OP_ON.7: "!on"
OP_DEFER.7: "!defer"

// Declaration keywords
OP_PARAM.7: ":param"
OP_BLOCK.7: ":block"


// ===== SHAPES =====
shape: TILDE shape_union shape_default?
?shape_union: shape_atom (PIPE shape_atom)*
shape_atom: (identifier | paren_shape | brace_shape) unit_suffix? limit_suffix? array_suffix?

unit_suffix: BRACKET_OPEN identifier BRACKET_CLOSE

limit_field: (identifier EQUALS)? simple_expr
limit_suffix: ANGLE_OPEN limit_field+ ANGLE_CLOSE

array_suffix: STAR array_count?
array_count: number MINUS number    // range: *4-8
           | number PLUS            // min-only: *4+
           | number                 // exact: *4
// Examples: *=any, *3=exactly 3, *3-5=range, *3+=min 3, *0-5=up to 5

paren_shape: PAREN_OPEN shape_content PAREN_CLOSE
brace_shape: BRACE_OPEN shape_content BRACE_CLOSE

shape_content: content_union | shape_field+
content_union: shape_atom (PIPE shape_atom)+
shape_field: (TOKENFIELD | shape | TOKENFIELD shape) shape_default?
shape_default: EQUALS field_default_value
?field_default_value: simple_expr | statement | structure


// ===== EXPRESSIONS =====
// Expression hierarchy defines operator precedence

wrapper: AT identifier

transaction: OP_TRANSACT PAREN_OPEN identifier+ PAREN_CLOSE
on_dispatch: OP_ON expression on_branch+
on_branch: shape expression
defer_expr: OP_DEFER expression

?expression: logic_or
           | transaction
           | on_dispatch
           | defer_expr

?logic_or: logic_and
         | logic_or LOR logic_and -> binary_op

?logic_and: comparison
          | logic_and LAND comparison -> binary_op

?comparison: arithmetic
           | comparison EQ arithmetic -> compare_op
           | comparison NE arithmetic -> compare_op
           | comparison CMP arithmetic -> compare_op
           | comparison ANGLE_OPEN arithmetic -> compare_op
           | comparison ANGLE_CLOSE arithmetic -> compare_op
           | comparison ANGLE_CLOSE EQUALS arithmetic -> compare_op  // >= when adjacent
           | comparison ANGLE_OPEN EQUALS arithmetic -> compare_op   // <= when adjacent

?arithmetic: term
           | arithmetic (PLUS | MINUS | KEBAB_MINUS) term -> binary_op

?term: pipeline_expr
     | term (STAR | SLASH) pipeline_expr -> binary_op

?pipeline_expr: binding_expr
              | binding_expr ((PIPE | PIPEFALLBACK) binding_expr)+ -> pipeline

?binding_expr: unary (COLON binding_value)*
?binding_value: identifier EQUALS unary | unary

?unary: postfix
      | (PLUS | MINUS | LNOT) unary -> unary_op

postfield: nextfield (DOT nextfield)*
?postfix: atom
        | atom DOT postfield -> fieldaccess

?atom: wrapper* (number | text | identifier | shape)
     | wrapper+   // Standalone wrapper(s) as a value
     | statement  // Paren structure as expression
     | structure  // Brace structure as expression


// ===== SIMPLE EXPRESSIONS =====
// Simplified expression hierarchy for use in default values and limits
// Avoids ambiguity by not allowing comparison operators

?simple_expr: simple_term
             | simple_expr (PLUS | MINUS | KEBAB_MINUS | LAND | LOR) simple_term -> binary_op

?simple_term: simple_atom
            | simple_term (STAR | SLASH) simple_atom -> binary_op

?simple_atom: wrapper* (number | text | identifier)
             | (PLUS | MINUS | LNOT) simple_atom -> unary_op


// ===== STRUCTURES & STATEMENTS =====
// Structures can contain statements
// Brace structures can contain field statements (named or unnamed)

statement: PAREN_OPEN statement_body PAREN_CLOSE
structure: BRACE_OPEN structure_body BRACE_CLOSE

statement_body: signature statement_item*
              | statement_item*

structure_body: signature structure_item*
              | structure_item*

statement_item: let_assign | expression
structure_item: let_assign | field_or_expr

field_or_expr: TOKENFIELD EQUALS expression -> named_field
             | expression

signature: (param_decl | block_decl)+
param_decl: OP_PARAM identifier shape (EQUALS simple_expr)?
block_decl: OP_BLOCK identifier shape (EQUALS simple_expr)?

let_assign: OP_LET identifier expression


// ===== IDENTIFIERS =====
TOKENFIELD.4: /[a-zA-Z_][\w-]*(?!\.\d)/  // Negative lookahead prevents matching sibling numbers

indexfield: HASH INTEGER
indexprfield: HASH PAREN_OPEN simple_expr PAREN_CLOSE
dollarfield: DOLLAR3 | DOLLAR2 | DOLLAR
exprfield: QUOTE expression QUOTE

?firstfield: TOKENFIELD -> tokenfield | dollarfield | exprfield
?nextfield: firstfield | indexfield | indexprfield | text -> textfield

identifier: firstfield (DOT nextfield)*


// ===== LITERALS =====

// Text literals - double quotes only (single quotes reserved for field expressions)
STRING.3: /[ubf]?r?"(?!"").*?(?<!\\)(\\\\)*?"/i
LONG_STRING.4: /[ubf]?r?""".*?(?<!\\)(\\\\)*?"""/is

text: STRING | LONG_STRING

// Numeric literals - higher priority than text content
INTBASE.3: /0[xXbBoO](_?[\da-zA-Z])+/  // Hex, binary, octal with underscores
SCIENTIFIC.3: /[eE][+-]?\d(_?\d)*/

INTEGER.3: INTBASE | /(([1-9](_?\d)*)|0(_?0)*)(?![a-zA-Z_"])/
DECIMAL.3: /\d(_?\d)*\.(\d(_?\d)*)?(SCIENTIFIC)?(?![a-zA-Z_"])/  // 3.14, 5., 1.5e-10
         | /\.\d(_?\d)*(SCIENTIFIC)?(?![a-zA-Z_])/             // .5, .123_456
         | /\d(_?\d)*SCIENTIFIC(?![a-zA-Z_"])/                 // 1e5, 1_000e10

number: INTEGER | DECIMAL


// ===== COMMENTS & WHITESPACE =====
// Comments are captured by the scanner but ignored during parsing
// Priority 7 to be higher than SLASH operator

COMMENT.7: /\/\/[^\r\n]*/        // Line comments: //
BLOCK_COMMENT.7: /\/\*.*?\*\//s  // Block comments: /* */
WS: /\s+/

%ignore WS
%ignore COMMENT
%ignore BLOCK_COMMENT
