// Comp Language Grammar v2 - Clean Restart
//
// Starting from the ground up with just literals and identifiers.
// Focus on simplicity and letting the grammar do the work, not the transformer.
//
// DESIGN PRINCIPLES:
// - Grammar rules should be self-explanatory
// - Minimize transformer complexity
// - Clear separation of concerns
// - Declarative over imperative

// === BASIC TOKENS ===

// Comments
COMMENT: /;[^\r\n]*/
%ignore COMMENT
%ignore /\s+/

// Structural tokens
LBRACE: "{"
RBRACE: "}"
LPAREN: "("
RPAREN: ")"


// === NUMBER LITERALS ===
// Identifies integer only values with bases, which need different parsing
// route. Allow underscores for readability. 
// Leading signs are handled by unary operators

number: INTBASE | DECIMAL

// Based number formats - unsigned, signs handled by unary operators
INTBASE.2: /0[xXbBoO](_?[\da-zA-Z])+/                      // All bases: hex, binary, octal

// Decimal formats - unsigned, signs handled by unary operators  
DECIMAL.1: /(([1-9](_?\d)*)|0(_?0)*)/                      // Integer: 123, 1_000, 0, 0_0 
         | /\d(_?\d)*\.(\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?/  // Decimal: 3.14, 5., 1.5e-10, 5.e10
         | /\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?/              // Leading dot: .5, .123_456, .5e10  
         | /\d(_?\d)*[eE][+-]?\d(_?\d)*/                   // Scientific integer: 1e5, 1_000e10


// === STRING LITERALS ===
// String parsing with separated quotes and content.
// Uses Python's regex patterns but separates quotes from content in parse tree.
// Ensures a content value is in the tree with the exact resulting string literal.

string: _short_string | _long_string

// Single quoted strings - quotes separated from content
_short_string: "\"" SHORT_STRING_CONTENT? "\""
SHORT_STRING_CONTENT: /[^"\\\r\n]+(?:\\.[^"\\\r\n]*)*/i

// Triple quoted strings - quotes separated from content  
SIXQUOTE:  "\"\"\""
_long_string: SIXQUOTE LONG_STRING_CONTENT? SIXQUOTE
LONG_STRING_CONTENT: /(.|\n)+?(?=""")/is


// === TOKEN ===

// The simplest name token for an identifier, UAX #31 compliant
// Allows dashes and single optional trailing question mark
TOKEN: /[^\W\d][\w-]*[?]?/
INDEXFIELD: /#\d+/
computefield: "'" atom "'"  // should use 'expression' later?


// individual component of an identifier
_field_leader: TOKEN | INDEXFIELD | computefield
_field_follower: _field_leader | string
identifier: _field_leader ("." _field_follower)*

LOCALSCOPE: "@"
ARGSCOPE: "^"
NAMESCOPE: "$" TOKEN

scope: LOCALSCOPE
     | LOCALSCOPE _field_follower
     | ARGSCOPE
     | ARGSCOPE _field_follower
     | NAMESCOPE
     | NAMESCOPE "." _field_follower


_qualified: scope | identifier


// === REFERENCE LITERALS ===
// References to tags, shapes, and functions. Possibly from other namespaces.
reference_identifiers: TOKEN ("." TOKEN)*
reference_namespace: "/" TOKEN?
_reference_path:  reference_identifiers reference_namespace?
tag_reference: "#" _reference_path
shape_reference: "~" _reference_path  
function_reference: "|" _reference_path
_function_piped: "|" _reference_path  // hidden for pipeline parsing


// === STRUCTURE DEFINITION ===
COLON_BLOCK_START: ":{"
SPREAD: ".."
structure: LBRACE _structure_content RBRACE
block: COLON_BLOCK_START _structure_content RBRACE
_structure_content: _structure_op* | pipeline
_structure_op: structure_spread | structure_assign | structure_unnamed
structure_spread: SPREAD expression
structure_assign: _qualified _assignment_op expression  
structure_unnamed: expression


// === ASSIGN EXPRESSIONS ===
// Assignments are not part of basic expressions, they are handled at specific
// points in the grammar
ASSIGN: "="
STRONG_ASSIGN: "=*"
WEAK_ASSIGN: "=?"
SPREAD_ASSIGN: "..="
STRONG_SPREAD_ASSIGN: "..=*"
WEAK_SPREAD_ASSIGN: "..=?"
_assignment_op: ASSIGN | STRONG_ASSIGN | WEAK_ASSIGN | SPREAD_ASSIGN | WEAK_SPREAD_ASSIGN | STRONG_SPREAD_ASSIGN


// === BASIC ATOM ===

// Atoms: the basic building blocks
?atom: number
     | string
     | _qualified
     | LPAREN expression RPAREN
     | tag_reference
     | structure
     | block


// Entry to the expression grammar
?expression: or_expr


// === PIPELINE EXPRESSIONS ===
// PIPE_FUNC: "|"
PIPE_FALLBACK: "|?"
PIPE_STRUCT: "|{"
PIPE_WRENCH: "|<<"
PIPE_BLOCK: "|:"

pipeline_func: _function_piped
pipeline_struct: PIPE_STRUCT _structure_op* RBRACE
pipeline_block: PIPE_BLOCK _qualified

pipeline: (pipeline_func | pipeline_struct | pipeline_block)+

// === BASIC EXPRESSIONS ===

// Boolean operators
LOGICAL_AND: "&&"
LOGICAL_OR: "||"
LOGICAL_NOT: "!!"
?or_expr: and_expr | or_expr LOGICAL_OR and_expr -> binary_op
?and_expr: not_expr | and_expr LOGICAL_AND not_expr -> binary_op
?not_expr: comparison | LOGICAL_NOT not_expr -> unary_op

// Comparison operators
EQUAL_EQUAL: "=="
NOT_EQUAL: "!="
LESS_THAN: "<"
LESS_EQUAL: "<="
GREATER_THAN: ">"
GREATER_EQUAL: ">="
!comp_op: EQUAL_EQUAL | NOT_EQUAL | LESS_THAN | LESS_EQUAL | GREATER_THAN | GREATER_EQUAL
?comparison: arith_expr | comparison comp_op arith_expr -> binary_op

// Number operators 
PLUS: "+"
MINUS: "-"
KEBAB_MINUS: "+-"  // Disambiguation for subtraction vs kebab-case identifiers
MULTIPLY: "*"
DIVIDE: "/"
MODULO: "%"
POWER: "**"
?arith_expr: term  // Arith (+, -, +-)
           | arith_expr PLUS term -> binary_op
           | arith_expr MINUS term -> binary_op
           | arith_expr KEBAB_MINUS term -> binary_op
?term: unary  // Terms (*, /, %)
     | term MULTIPLY unary -> binary_op
     | term DIVIDE unary -> binary_op
     | term MODULO unary -> binary_op
?unary: power  // Factors (unary +/-)
       | PLUS unary -> unary_op
       | MINUS unary -> unary_op
?power: atom_in_expr  // Power (**) - right-associative  
      | atom_in_expr POWER unary -> binary_op


// === ATOM EXPRESSIONS ===
// Use of atoms to continue building expressions
// PRIVATEATTACH: "&"
// PRIVATEFIELD: "&."
?atom_in_expr: atom
             | atom_in_expr "." _field_follower -> atom_field
             | atom_in_expr pipeline -> atom_pipeline
//          //  | atom_in_expr PRIVATEATTACH -> atom_private
//          //  | atom_in_expr PRIVATEFIELD identifier -> atom_private_field
//          //  | scope_identifier -> field_access_operation


