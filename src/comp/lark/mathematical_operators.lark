// Mathematical operators grammar for Comp language
// Supports arithmetic, comparison, logical operators with proper precedence

// Import necessary components for atoms
%import numbers (number)
%import identifiers (identifier)  
%import strings (string)
%import references (tag_reference, shape_reference, function_reference)

// Operator tokens
PLUS: "+"
MINUS: "-"
MULTIPLY: "*"
DIVIDE: "/"
MODULO: "%"
POWER: "**"

EQUAL_EQUAL: "=="
NOT_EQUAL: "!="
LESS_THAN: "<"
LESS_EQUAL: "<="
GREATER_THAN: ">"
GREATER_EQUAL: ">="

LOGICAL_AND: "&&"
LOGICAL_OR: "||"
LOGICAL_NOT: "!!"

LPAREN: "("
RPAREN: ")"

// Structure tokens
LBRACE: "{"
RBRACE: "}"
EQUALS: "="

// Expression rules with proper precedence (lowest to highest)
// Following standard mathematical precedence

?math_expression: logical_or

// Logical OR (lowest precedence)
?logical_or: logical_and
           | logical_or LOGICAL_OR logical_and -> binary_operation

// Logical AND  
?logical_and: equality
            | logical_and LOGICAL_AND equality -> binary_operation

// Equality operators
?equality: comparison
         | equality EQUAL_EQUAL comparison -> binary_operation
         | equality NOT_EQUAL comparison -> binary_operation

// Comparison operators  
?comparison: additive
           | comparison LESS_THAN additive -> binary_operation
           | comparison LESS_EQUAL additive -> binary_operation
           | comparison GREATER_THAN additive -> binary_operation
           | comparison GREATER_EQUAL additive -> binary_operation

// Additive operators
?additive: multiplicative
         | additive PLUS multiplicative -> binary_operation
         | additive MINUS multiplicative -> binary_operation

// Multiplicative operators
?multiplicative: power
               | multiplicative MULTIPLY power -> binary_operation
               | multiplicative DIVIDE power -> binary_operation
               | multiplicative MODULO power -> binary_operation

// Power operator (right-associative, highest precedence for binary)
?power: unary
      | unary POWER power -> binary_operation

// Unary operators (highest precedence)
?unary: primary
      | PLUS unary -> unary_operation
      | MINUS unary -> unary_operation  
      | LOGICAL_NOT unary -> unary_operation

// Primary expressions
?primary: number 
        | string 
        | identifier 
        | tag_reference 
        | shape_reference 
        | function_reference
        | structure
        | LPAREN math_expression RPAREN

// Structure literal: {field1 field2 ...}
structure: LBRACE structure_field* RBRACE

// Structure fields can be either named (key=value) or positional (value)
structure_field: named_field | positional_field

// Named field: identifier=expression or string=expression  
named_field: (identifier | string) EQUALS math_expression

// Positional field: just an expression
positional_field: math_expression