; Struct operations for finite collections
; Focus on field manipulation and indexed access


; === Query/Test Operations ===

; !doc "Filter only fields with defined names"
!func |named ~struct = {
    ???
}


; !doc "Filter only fields without defined names"
!func |unnamed ~struct = {
    ???
}


; !doc "Check if struct is empty (short-circuits on first element)"
!func |empty? ~struct = {
    ???
}


; !doc "Count total fields"
!func |length ~struct = {
    $var.count = 0
    [$in |iter :{
        $var.count = [$var.count + 1]
    }]
    $var.count
}


; !doc "Get index position of named field (returns num or fail)"
!func |field-index ~struct arg ~{field ~str} = {
    ???
}


; === Access Operations ===

; !doc "Get first element (or first N elements if count given)"
!func |first ~struct arg ~{count ~num=1} = {
    [$arg.count == 1
        |if then: {[$in |at index: 0]}
            else: {[$in |slice start: 0 end: $arg.count]}
    ]
}


; !doc "Get last element (or last N elements if count given)"
!func |last ~struct arg ~{count ~num=1} = {
    [$arg.count == 1
        |if then: {[$in |at index: -1]}
            else: {
                $var.len = [$in |length]
                $var.start = [$var.len - $arg.count]
                [$in |slice start: $var.start end: $var.len]
            }
    ]
}


; !doc "Get range of elements"
!func |slice ~struct arg ~{start ~num end ~num} = {
    $var.result = []
    $var.idx = 0
    [$in |iter :{
        [[$var.idx >= $arg.start] && [$var.idx < $arg.end]
            |if then: {
                $var.result = [$var.result !append $in.value]
            }
        ]
        $var.idx = [$var.idx + 1]
    }]
    $var.result
}


; !doc "Get element at index (supports negative indexing, -1 for last)"
!func |at ~struct arg ~{index ~num} = {
    $var.target = [$arg.index < 0
        |if then: {[[$in |length] + $arg.index]}
            else: {$arg.index}
    ]
    $var.idx = 0
    $var.found = !fail "index out of bounds"
    [$in |iter :{
        [$var.idx == $var.target
            |if then: {$var.found = $in.value}
        ]
        $var.idx = [$var.idx + 1]
    }]
    $var.found
}


; !doc "Find first element matching condition"
!func |find ~struct arg ~{if ~:{}} = {
    $var.result = !fail "not found"
    [$in |iter :{
        [$in.value |:$arg.if
            |if then: {
                $var.result = $in.value
                !break
            }
        ]
    }]
    $var.result
}


; !doc "Check if struct contains value"
!func |contains? ~struct arg ~{value ~any} = {
    $var.found = false
    [$in |iter :{
        [$in.value == $arg.value
            |if then: {
                $var.found = true
                !break
            }
        ]
    }]
    $var.found
}


; !doc "Get all items as list of {field value} pairs"
!func |items ~struct = {
    ???
}


; === Transform Operations ===

; !doc "Reverse field order"
!func |reverse ~struct = {
    $var.result = []
    [$in |iter :{
        $var.result = [$in.value $var.result]
    }]
    $var.result
}


; !doc "Sort by value (optionally by key function)"
!func |sort ~struct arg ~{key ~:{}={}} = {
    ???
}


; !doc "Sort by field names"
!func |sort-fields ~struct = {
    ???
}


; !doc "Rotate fields left (negative) or right (positive)"
!func |rotate ~struct arg ~{by ~num} = {
    ???
}


; === Field Manipulation ===

; !doc "Rename fields (takes mapping struct or from/to args)"
!func |rename ~struct arg ~{from ~str to ~str} = {
    ???
}


; !doc "Remove specified fields"
!func |drop ~struct arg ~{fields ~[str]} = {
    $var.result = {}
    [$in |iter :{
        [$arg.fields |contains? value: $in.field
            |if else: {
                $var.result = {$var.result $in.field: $in.value}
            }
        ]
    }]
    $var.result
}


; !doc "Keep only specified fields"
!func |select ~struct arg ~{fields ~[str]} = {
    $var.result = {}
    [$arg.fields |iter :{
        $var.result = {$var.result $in.value: $in.field.$in.value}
    }]
    $var.result
}


; !doc "Reorder fields to match list"
!func |reorder ~struct arg ~{fields ~[str]} = {
    ???
}


; !doc "Copy field structure from another struct"
!func |apply-fields ~struct arg ~{template ~struct} = {
    ???
}

!doc "Assign field names from one structure values to another structure values"
!func |apply-names ~struct arg ~{names~any} = {
    ..[{$arg.names $in} |zip |iter :{
        '$in.#0' = $in.#1
    }]
}


; === Content Manipulation ===

; !doc "Insert value at position"
!func |insert ~struct arg ~{at ~num value ~any} = {
    ???
}


; !doc "Remove element at position (or range if count given)"
!func |remove ~struct arg ~{at ~num count ~num=1} = {
    ???
}


; !doc "Replace range with new values"
!func |replace ~struct arg ~{at ~num count ~num values ~[]} = {
    ???
}


; !doc "Extract fields by indices or names"
!func |take ~struct arg ~{fields ~[]} = {
    ???
}


; !doc "Fill struct with value repeated count times"
!func |fill ~struct arg ~{value ~any count ~num} = {
    ???
}


; !doc "Pad struct to length with value"
!func |pad ~struct arg ~{length ~num value ~any} = {
    ???
}


; === Combination/Conversion ===

; !doc "Combine multiple lists into list of structs"
!func |zip ~struct arg ~{lists ~[]} = {
    ???
}


; !doc "Split struct-of-lists into list-of-structs"
!func |unzip ~struct = {
    ???
}


; !doc "Extract just values (ignoring field names)"
!func |values ~struct = {
    $var.result = []
    [$in |iter :{
        $var.result = [$var.result !append $in.value]
    }]
    $var.result
}


; !doc "Extract just field names"
!func |fields ~struct = {
    ???
}


; !doc "Convert list of {field value} pairs to struct"
!func |from-pairs ~struct = {
    ???
}


; === Shape Operations ===

; !doc "Morph to match another struct's field structure"
!func |field-morph ~struct arg ~{template ~struct} = {
    ???
}


; !doc "Mask to intersection of fields with another struct"
!func |field-mask ~struct arg ~{template ~struct} = {
    ???
}


; === Test Operations with Patterns ===

; !doc "Test if struct starts with prefix"
!func |starts-with? ~struct arg ~{prefix ~[]} = {
    ???
}


; !doc "Test if struct ends with suffix"
!func |ends-with? ~struct arg ~{suffix ~[]} = {
    ???
}
