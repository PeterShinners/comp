/// Iteration and looping functions
/// Functions for generating sequences, mapping, filtering, and reducing.


/// Generate infinite counter stream
!func infinite (
    !params start~num=0 step~num=1
    stream (
        {value=$ next=($ + step)}
    ) [seed=start]
)

/// Generate range of numbers
!pure range (
    !params start~num=0 end~num step~num=1

    !on (step == 0)
    ~true (fail["range step cannot be zero"])
    ~false (
        unfold[seed=start] (
            !on ($ >= end)
            ~true done
            ~false {value=$ next=($ + step)}
        )
    )
)

/// Generate indices for input collection
!pure indices ~struct (
    range[end=($ | length)]
)

/// Execute operation on each element (side effects)
!func each ~struct (
    !block op
    $ | enumerate | map ($value | op)
)

/// Map operation over collection elements
!pure map ~struct (
    !block op
    $ | enumerate | map ($value | op)
)

/// Test if any element matches condition
!pure any ~struct (
    !block test
    $ | filter (test) | empty | not
)

/// Test if all elements match condition
!pure all ~struct (
    !block test
    $ | filter (not (test)) | empty
)

/// Test if no elements match condition
!pure none ~struct (
    !block test
    $ | any (test) | not
)

/// Count elements matching optional condition
!pure count ~struct (
    !block test=pass
    $ | filter (test) | length
)

/// Filter elements matching condition
!pure filter ~struct (
    !block test
    $ | enumerate | filter ($value | test) | map ($value)
)

/// Group consecutive elements into fixed-size chunks
!pure chunk ~struct (
    !params size~num
    !let len ($ | length)
    range[start=0 end=len step=size]
    | map ($ | slice[start=$ end=(min[$ + size len])])
)

/// Reduce sequence to single value
!pure reduce ~struct (
    !params initial
    !block fold
    //x this likely needs a builtin or recursive approach
    //x since we can't mutate an accumulator
    $ | builtin.reduce[initial] (fold)
)

/// Unfold: generate sequence from seed
!pure unfold (
    !params seed
    !block step
    !block collect=pass
    //x needs runtime support for lazy generation
    builtin.unfold[seed] (step) (collect)
)

/// Extract positional digits from number in given base
!pure digits ~num (
    !params base~num=10
    unfold[seed=$] (
        !on ($ == 0)
        ~true done
        ~false (
            !let d ($ | divmod[base])
            {value=d.remainder next=d.division}
        )
    )
)

/// Find first element matching condition
!pure find ~struct (
    !block test
    $ | filter (test) | first
)

/// Take first n elements
!pure take ~struct (
    !params count~num
    $ | slice[start=0 end=count]
)

/// Drop first n elements
!pure drop ~struct (
    !params count~num
    $ | slice[start=count end=($ | length)]
)

/// Flatten nested structures
!pure flat ~struct @flat (
    $ | map (
        !on ($ ~struct)
        ~true ($ | flat)
        ~false $
    )
)

/// Zip multiple sequences together
!pure zip ~struct (
    !params others~struct
    !let min-len (
        {($ | length)} | append (others | map (length)) | min
    )
    range[end=min-len]
    | map (
        !let idx $
        {($ | at[index=idx])} | append (others | map (at[index=idx]))
    )
)