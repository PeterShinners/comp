; !import /struct = comp "struct"  ; Commented out - has parse errors, using builtin |length instead
; !doc "Iteration and looping functions"


; !doc "Infinite counter stream"  
!func |infinite ~{} arg ~{start~num=0 step~num=1} = {
    $var.count = $arg.start
    :{
        $var.result = $var.count
        $var.count = $var.count + $arg.step
        $var.result
    }~any-block
}


; !doc "Generate range of numbers from start to end (exclusive) with optional step"
!func |range ~any arg ~{start~num=0 end~num step~num=1} = {
    ..[|if ($arg.step <= 0) :{#fail "range step must be positive"} :{
        $var.current = $arg.start
        
        ..[|loop :{
            [|if ($var.current >= $arg.end) :{#break} :{
                $var.result = $var.current
                $var.current = $var.current + $arg.step
                $var.result
            }]
        }]
    }]
}

; !func |range-b ~num arg ~{end ~num start ~num =0 step ~num = 1} = {
;     [|if ($arg.step == 0) :{#fail "range step cannot be zero"}]
;     $var.current = $arg.start
;     ..[|loop :{
;         (($arg.step > 0 && $var.current >= $arg.end) ||
;          ($arg.step < 0 && $var.current <= $arg.end)) |if :{#break}
;         $var.value = $var.current
;         $var.current = $var.current + $arg.step
;         $var.value
;     }]
; }


; !doc "Generate indices for input collection (0 to length-1)"
!func |indices ~struct = {
    ..[|range end=[$in |length]]
}



!func |iter ~struct arg ~{~any} = {
    $var.collection-item = [$arg |subscript index=0]
    $var.collection = $var.collection-item.value
    $var.op-item = [$arg |subscript index=1]
    $var.op = $var.op-item.value
    $var.length = [$var.collection |length]
    $var.index = 0
    
    ..[|loop :{
        [|if ($var.index >= $var.length) :{#break} :{
            $var.item = [$var.collection |subscript index=$var.index]
            $var.index = ($var.index + 1)
            $var.data = {
                value = $var.item.value
                field = $var.item.field
                index = ($var.index - 1)
            }
            [$var.data |:$var.op]
        }]
    }]
}


!func |map ~struct arg ~{op ~:{}} = {
    ..[$in |iter :{
        [$in.value |:$arg.op]
    }]
}


; !doc "Test if any element matches condition"
!func |any? ~struct arg ~{if ~:{}} = {
    ???
}


; !doc "Test if all elements match condition"
!func |all? ~struct arg ~{if ~:{}} = {
    ???
}


; !doc "Test if no elements match condition"
!func |none? ~struct arg ~{if ~:{}} = {
    ???
}


; !doc "Count elements matching condition (defaults to non-fail values)"
!func |count ~struct arg ~{if ~:{}={}} = {
    ???
}


; !doc "Filter elements matching condition"
!func |filter ~struct arg ~{if ~:{}} = {
    ???
}


; !doc "Group consecutive elements into fixed-size chunks"
!func |chunk ~struct arg ~{size ~num} = {
    ???
}


; !doc "Group elements by key function result"
!func |group ~struct arg ~{key ~:{}} = {
    ???
}


; !doc "Flatten nested structures into single sequence"
; TODO: Needs recursion support - stubbed for now
!func |flat ~struct arg ~{depth ~num = 1} = {
    ???
}


; !doc "Reduce sequence to single value using fold function"
!func |reduce ~struct arg ~{initial ~any fold ~:{accumulator value}} = {
    $var.result = $arg.initial
    [$in |iter :{
        $var.result = [{accumulator=$var.result value=$in.value} |:$arg.fold]
    }]
    $var.result
}


; !doc "Split sequence at index position"
!func |split ~struct arg ~{index ~num} = {
    ???
}


; !doc "Partition elements into two groups based on condition"
!func |partition ~struct arg ~{if ~:{}} = {
    ???
}


; !doc "Remove duplicate elements (optionally by key)"
!func |unique ~struct arg ~{key ~:{}={}} = {
    ???
}


; !doc "Repeat sequence n times or element infinitely"
!func |repeat ~struct arg ~{times ~num={}} = {
    ???
}


; !doc "Duplicate stream for multiple independent consumers"
!func |tee ~struct arg ~{count ~num = 2} = {
    ???
}


; !doc "Convert pairs of {field value} into structure"
!func |from-pairs ~struct = {
    ???
}


; !doc "Find insertion index for value in sorted sequence (optionally by key)"
!func |bisect ~struct arg ~{value ~any key ~:{}={}} = {
    ???
}


; !doc "Concatenate sequence of sequences into single sequence"
!func |join ~struct = {
    ???
}

