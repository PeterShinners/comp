/// Iteration and looping functions
/// Functions for generating sequences, mapping, filtering, and reducing.


/// Generate infinite counter stream
!func infinite (
    :param start~num=0 
    :param step~num=1
    stream (
        {value=$ next=($ + step)}
    )  :seed=start
)

/// Generate range of numbers
!pure range (
    :param start~num=0 
    :param end~num 
    :param step~num=1

    !on (step == 0)
    ~true (fail :"range step cannot be zero")
    ~false (
        unfold :seed=start (
            !on ($ >= end)
            ~true done
            ~false {value=$ next=($ + step)}
        )
    )
)

/// Generate indices for input collection
!pure indices ~struct (
    range :end=length
)

/// Execute operation on each element (side effects)
!func each ~struct (
    :block op
    $ | enumerate | map :($.value | op)
)

/// Map operation over collection elements
!pure map ~struct (
    :block op
    $ | enumerate | map :($.value | op)
)

/// Test if any element matches condition
!pure any ~struct (
    :block test
    $ | filter :test | !not empty
)

/// Test if all elements match condition
!pure all ~struct (
    :block test
    $ | filter :(!not test) | empty
)

/// Test if no elements match condition
!pure none ~struct (
    :block test
    $ | !not any :test
)

/// Count elements matching optional condition
!pure count ~struct (
    :block test=pass
    $ | filter :test | length
)

/// Filter elements matching condition
!pure filter ~struct (
    :block test
    $ | enumerate | filter :($.value | test) | map :($.value)
)

/// Group consecutive elements into fixed-size chunks
!pure chunk ~struct (
    :param size~num
    !let len ($ | length)
    range :start=0 :end=len :step=size
    | map :($ | slice :start=$ :end=(min :$ + size len))
)

/// Reduce sequence to single value
!pure reduce ~struct (
    :param initial
    :block fold
    //x this likely needs a builtin or recursive approach
    //x since we can't mutate an accumulator
    $ | builtin.reduce :initial :fold
)

/// Unfold: generate sequence from seed
!pure unfold (
    :param seed
    :block step
    :block collect=pass
    //x needs runtime support for lazy generation
    builtin.unfold :seed :step :collect
)

/// Extract positional digits from number in given base
!pure digits ~num (
    :param base~num=10
    unfold :seed=$ (
        !on $ == 0
        ~true done
        ~false (
            !let d ($ | divmod :base)
            {value=d.remainder next=d.division}
        )
    )
)

/// Find first element matching condition
!pure find ~struct (
    :block test
    $ | filter :test | first
)

/// Take first n elements
!pure take ~struct (
    :param count~num
    $ | slice :start=0 end=count
)

/// Drop first n elements
!pure drop ~struct (
    :param count~num
    $ | slice :start=count :end=length
)

/// Flatten nested structures
!pure flat ~struct @flat (
    $ | map (
        !on ($ ~struct)
        ~true ($ | flat)
        ~false $
    )
)

/// Zip multiple sequences together
!pure zip ~struct (
    :param others~struct
    !let min-len (
        {($ | length)} | append (others | map :length) | min
    )
    range :end=min-len
    | map (
        !let idx $
        {($ | at :index=idx)} | append (others | map :at :index=idx)
    )
)