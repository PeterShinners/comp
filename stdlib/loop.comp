--- Iteration and looping functions
Functions for generating sequences, mapping, filtering, and reducing collections.
---


-- Generate infinite counter stream starting at a value with step increments

infinite = :arg~(start~num=0 step~num=1) (
	!var.count = arg.start
	:(
		var.count
		!var.count = var.count + arg.step
	)
)


-- Generate range of numbers from start to end (exclusive) with optional step

range = :arg~(start~num=0 end~num step~num=1) pure (
	if(arg.step == 0) :(fail("range step cannot be zero"))
	!var.current = arg.start
	|flat |loop :(
		if(var.current >= arg.end) :(break)
		|else :(
			var.current
			!var.current = var.current + arg.step
		)
	)
)


-- Generate indices for input collection (0 to length-1)

indices = :in~struct pure (|flat
	range(end=(in |length()))
)


-- Execute operation on each element of collection

each = :in~struct arg~(op~:()) (|flat
	in |loop :(
		if(it.index >= in |length()) :(break)
		|else :(
			!var.item = in |at(index=it.index)
			var.item |:arg.op()
			!var.index = it.index + 1
		)
	)
)


-- Map operation over collection elements

map = :in~struct arg~(op~:()) pure (|flat
	in |loop :(
		if(it.index >= in |length()) :(break)
		|else :(
			!var.item = in |at(index=it.index)
			var.item |:arg.op()
			!var.index = it.index + 1
		)
	)
)


-- Test if any element matches condition

any? = :in~struct arg~(test~:()) pure (|val
	!var.found = false
	in |loop :(
		if(it.index >= in |length()) :(break)
		|else :(
			!var.item = in |at(index=it.index)
			if(var.item |:arg.test()) :(
				!var.found = true
				break
			)
			!var.index = it.index + 1
		)
	)
	var.found
)


-- Test if all elements match condition

all? = :in~struct arg~(test~:()) pure (|val
	!var.all-match = true
	in |loop :(
		if(it.index >= in |length()) :(break)
		|else :(
			!var.item = in |at(index=it.index)
			if(!!(var.item |:arg.test())) :(
				!var.all-match = false
				break
			)
			!var.index = it.index + 1
		)
	)
	var.all-match
)


-- Test if no elements match condition

none? = :in~struct arg~(test~:()) pure (|val
	!!(in |any?(test=arg.test))
)


-- Count elements matching condition

count = :in~struct arg~(test~:()=:(_)(true)) pure (|val
	!var.count = 0
	in |loop :(
		if(it.index >= in |length()) :(break)
		|else :(
			!var.item = in |at(index=it.index)
			if(var.item |:arg.test()) :(
				!var.count = var.count + 1
			)
			!var.index = it.index + 1
		)
	)
	var.count
)


-- Filter elements matching condition

filter = :in~struct arg~(test~:()) pure (|flat
	in |loop :(
		if(it.index >= in |length()) :(break)
		|else :(
			!var.item = in |at(index=it.index)
			if(var.item |:arg.test()) :(var.item)
			!var.index = it.index + 1
		)
	)
)


-- Group consecutive elements into fixed-size chunks

chunk = :in~struct arg~(size~num) pure (|flat
	!var.index = 0
	!var.len = in |length()
	loop :(
		if(var.index >= var.len) :(break)
		|else :(
			!var.end = var.index + arg.size
			if(var.end > var.len) :(!var.end = var.len)
			in |slice(start=var.index end=var.end)
			!var.index = var.end
		)
	)
)


-- Reduce sequence to single value using fold function

reduce = :in~struct arg~(initial~any fold~:()) (|val
	!var.result = arg.initial
	in |loop :(
		if(it.index >= in |length()) :(break)
		|else :(
			!var.item = in |at(index=it.index)
			!var.result = (accumulator=var.result value=var.item) |:arg.fold()
			!var.index = it.index + 1
		)
	)
	var.result
)


-- Unfold: Generate sequence by repeatedly applying function until condition met
-- Like reduce in reverse - starts with seed, generates values until done
-- The step function receives current state, returns (value=..., next=..., done=...)

unfold = :arg~(seed~any step~:() collect~:()=:(state)(state)) pure (|flat
	!var.state = arg.seed
	loop :(
		!var.result = var.state |:arg.step()
		if(var.result.done) :(break)
		|else :(
			var.result.value |:arg.collect()
			!var.state = var.result.next
		)
	)
)


-- Extract positional digits from a number in given base (default base 10)
-- Returns digits in reverse order (least significant first)

digits = :~num arg~(base~num=10) pure (|flat
	!var.n = num
	loop :(
		if(var.n == 0) :(break)
		|else :(
			!var.div = var.n | divmod(arg.base)
			div.remainder
			!var.n = div.division
		)
	)
)


-- Find first element matching condition

find = :in~struct arg~(test~:()) pure (|val
	!var.found = nil
	in |loop :(
		if(it.index >= in |length()) :(break)
		|else :(
			!var.item = in |at(index=it.index)
			if(var.item |:arg.test()) :(
				!var.found = var.item
				break
			)
			!var.index = it.index + 1
		)
	)
	var.found
)


-- Take first n elements from collection

take = :in~struct arg~(count~num) pure (
	in |slice(start=0 end=arg.count)
)


-- Drop first n elements from collection

drop = :in~struct arg~(count~num) pure (
	in |slice(start=arg.count end=(in |length()))
)


-- Flatten nested structures into single sequence

flat = :in~struct pure (|flat
	in |loop :(
		if(it.index >= in |length()) :(break)
		|else :(
			!var.item = in |at(index=it.index)
			-- Simple flatten - if item is struct, expand it
			if(var.item ~struct) :(|flat var.item)
			|else :(var.item)
			!var.index = it.index + 1
		)
	)
)


-- Zip multiple sequences together

zip = :in~struct arg~(lists~struct) pure (|flat
	!var.min-len = in |length()
	arg.lists |each :lst (
		!var.len = lst |length()
		if(var.len < var.min-len) :(!var.min-len = var.len)
	)

	range(end=var.min-len) |map :idx (|flat
		in |at(index=idx)
		arg.lists |map :lst (lst |at(index=idx))
	)
)
