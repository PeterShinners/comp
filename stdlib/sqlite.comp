/// Simple SQLite interface for Comp
/// Basic database operations using Python's sqlite3 module.

!import py comp "core:python"


!shape handle-db ~{}

!tag isolation {deferred exclusive immediate none}

!tag fail {
    interface       /// Connection/cursor management errors
    database        /// Database file/format errors
    data            /// Data type conversion errors
    operation       /// SQL operation errors
    integrity       /// Constraint violations
    internal        /// Internal SQLite errors
    programming     /// API misuse errors
    notsupported    /// Feature not supported
}

!shape connect-args ~{
    timeout~num = 5
    isolation-level~isolation = isolation.deferred
}

!shape execute-result ~{
    rows~struct
    columns~struct
    row-id~num
    row-count~num
}


/// Map Python sqlite3 exception types to Comp fail tags
!let exception-tags {
    interface-error = fail.interface
    database-error = fail.database
    data-error = fail.data
    operational-error = fail.operation
    integrity-error = fail.integrity
    internal-error = fail.internal
    programming-error = fail.programming
    not-supported-error = fail.notsupported
}


/// Test function that raises a Python sqlite exception
!func test-sqlite-error (
    py.call-func :name="sqlite3.connect"
        {database="/invalid/path/that/does/not/exist/test.db"}
)


/// Open database connection from file path
!func database-file ~text (
    :params connect-args
    !let pydb (py.call-func :name="sqlite3.connect" {database=$})
    !let db (grab-handle :handle-db)
    db @update {private.py = pydb}
)

/// Open database connection from URL
!func database-url ~text (
    :params connect-args
    !let pydb (py.call-func :name="sqlite3.connect" :{database=$ url=true})
    !let db (grab-handle :handle-db)
    db @update :{private.py = pydb}
)

/// Open in-memory database
!func database-memory (
    :params connect-args
    !let pydb (py.call-func :name="sqlite3.connect" :{database=":memory:"})
    !let db (grab-handle :handle-db)
    db @update :{private.py = pydb}
)

/// Execute SQL statement and return results
!func execute ~{db~handle-db} (
    :param sql~text

    !let cursor (py.call :method="cursor" {self=$.db.private.py})
    !let exec (py.call :method="execute" :{self=cursor sql})
    !let cursor-vars (py.call :method="vars" :{self=cursor})

    execute-result {
        rows = (py.call :method="fetchall" :{self=cursor} | py.pull)
        columns = cursor-vars.description
        row-id = cursor-vars.lastrowid
        row-count = cursor-vars.rowcount
    }
)

/// Called automatically as handle is dropped
!func drop-handle ~{db~handle-db} (
    py.call :method="close" :{self=$.db.private.py}
)