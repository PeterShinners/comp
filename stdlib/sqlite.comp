!doc module "Simple SQLite interface for Comp"

!import /py = stdlib "python"

!doc "Connection to open database resource"
!handle @db

!tag #isolation = {#deferred #exclusive #immediate #none}

; Extend builtin #fail with SQLite-specific error categories
!tag #fail extends #fail/builtin = {
    #interface      ; Connection/cursor management errors
    #database       ; Database file/format errors
    #data           ; Data type conversion errors
    #operation      ; SQL operation errors
    #integrity      ; Constraint violations
    #internal       ; Internal SQLite errors
    #programming    ; API misuse errors
    #notsupported   ; Feature not supported
}

!shape ~connect-args = {
    timeout ~num = 5
    isolation-level #isolation = #deferred
}

; Map Python sqlite3 exception types to Comp fail tags
$mod.exception-tags = {
    InterfaceError = #fail.interface
    DatabaseError = #fail.database
    DataError = #fail.data
    OperationalError = #fail.operation
    IntegrityError = #fail.integrity
    InternalError = #fail.internal
    ProgrammingError = #fail.programming
    NotSupportedError = #fail.notsupported
}

!doc "Test function to verify #fail.database is treated as a real failure"
!func |test-fail ~{} = {
    {#fail.database message="The database has failed"}
}

!doc "Test function that raises a Python sqlite exception"
!func |test-sqlite-error ~{} = {
    ; Try to connect to a database with an invalid path
    [{database="/invalid/path/that/does/not/exist/test.db"} |call-func/py "sqlite3.connect"]
}

!doc "Result of execute calls"
!shape ~execute = {
    rows ~any
    columns ~any
    row-id ~any
    row-count ~num
}

!doc "Open database connection"
!func |database-file ~str arg ~connect-args = {
    $var.pydb = [{database=$in} |call-func/py "sqlite3.connect"]
    $var.db = !grab @db
    $var.db&py = $var.pydb
    $var.db
}

!func |database-url ~str arg ~connect-args = {
    $var.pydb = [{database=$in url=#true} |call-func "sqlite3.connect"]
    $var.db = !grab @db
    $var.db&py = $var.pydb
    $var.db
}

!func |database-memory ~{} arg ~connect-args = {
    $var.pydb = [{database=":memory:"} |call-func "sqlite3.connect"]
    $var.db = !grab @db
    $var.db&py = $var.pydb
    $var.db
}

!doc "Execute SQL statement and return ~execute"
!func |execute ~{db @db} arg ~{sql ~str} = {
    $var.cursor = [{self=$in.db&py} |call "cursor"]
    $var.exec = [{self=$var.cursor $arg.sql} |call "execute"]
    $var.cursor-vars = [{self=$var.cursor} |vars]
    
    

    ; TODO: Convert row tuples to structs with column names from description
    rows = [{self=$var.cursor} |call "fetchall" |pull]
    columns = $var.cursor-vars.description
    row-id = $var.cursor-vars.lastrowid
    row-count = $var.cursor-vars.rowcount
}

; called automatically as handle is dropped
!func |drop-handle& ~{db@db} = {
    [$in.db&py |call "close"]
}
