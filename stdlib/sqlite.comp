!doc module "Simple SQLite interface for Comp"

!import /py = stdlib "python"

!handle @db

!tag #isolation = {#deferred #exclusive #immediate #none}

; Extend builtin #fail with SQLite-specific error categories
!tag #fail extends #fail/builtin = {
    #interface      ; Connection/cursor management errors
    #database       ; Database file/format errors
    #data           ; Data type conversion errors
    #operation      ; SQL operation errors
    #integrity      ; Constraint violations
    #internal       ; Internal SQLite errors
    #programming    ; API misuse errors
    #notsupported   ; Feature not supported
}

!shape ~connect-args = {
    timeout ~num = 5
    isolation-level #isolation = #isolation.deferred
}

; Map Python sqlite3 exception types to Comp fail tags
; TODO: Requires !disarm operator to store fail tags without propagation
; $mod.fail-map = {
;     InterfaceError = !disarm #fail.interface
;     DatabaseError = !disarm #fail.database
;     DataError = !disarm #fail.data
;     OperationalError = !disarm #fail.operation
;     IntegrityError = !disarm #fail.integrity
;     InternalError = !disarm #fail.internal
;     ProgrammingError = !disarm #fail.programming
;     NotSupportedError = !disarm #fail.notsupported
; }

!doc "Test function to verify #fail.database is treated as a real failure"
!func |test-fail ~{} = {
    {#fail.database message="The database has failed"}
}

!doc "Test function that raises a Python sqlite exception"
!func |test-sqlite-error ~{} = {
    ; Try to connect to a database with an invalid path
    [{database="/invalid/path/that/does/not/exist/test.db"} |call-func/py "sqlite3.connect"]
    ; TODO: Add error mapping with |? handler once !disarm is implemented
}

!doc "Result of execute calls"
!shape ~execute = {
    rows ~any
    columns ~any
    row-id ~any
    row-count ~num
}

; TODO: Re-enable once !disarm operator is implemented
; !doc "Map Python sqlite3 exceptions to Comp fail tags"
; !func |map-sqlite-error ~any = {
;     $var.exc-type = $in.exception_type
;     $var.tag-block = $mod.fail-map.'$var.exc-type' ?? :{#fail}
;     $var.fail-tag = [{} |: $var.tag-block]
;     {fail=$var.fail-tag message=$in.message cause=$in}
; }

!doc "Open database connection"
!func |database-file ~str arg ~connect-args = {
    $var.pydb = [{database=$in} |call-func/py "sqlite3.connect"]
    ; TODO: Add error mapping with |? handler once !disarm is implemented
    $var.db = !grab @db
    $var.db&py = $var.pydb
    $var.db
}

!func |database-url ~str arg ~connect-args = {
    $var.pydb = [{database=$in url=#true} |call-func "sqlite3.connect"]
    $var.db = !grab @db
    $var.db&py = $var.pydb
    $var.db
}

!func |database-memory ~{} arg ~connect-args = {
    $var.pydb = [{database=":memory:"} |call-func "sqlite3.connect"]
    $var.db = !grab @db
    $var.db&py = $var.pydb
    $var.db
}

!doc "Execute SQL statement and return ~execute"
!func |execute ~{db @db} arg ~{sql ~str} = {
    $var.cursor = [{self=$in.db&py} |call "cursor"]
    $var.exec = [{self=$var.cursor $arg.sql} |call "execute"]
    $var.cursor-vars = [{self=$var.cursor} |vars]
    
    

    ; TODO: Convert row tuples to structs with column names from description
    rows = [{self=$var.cursor} |call "fetchall" |pull]
    columns = $var.cursor-vars.description
    row-id = $var.cursor-vars.lastrowid
    row-count = $var.cursor-vars.rowcount
}

; called automatically as handle is dropped
!func |drop-handle& ~{db@db} = {
    [$in.db&py |call "close"]
}
