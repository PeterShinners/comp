!import /py = stdlib "python"


!func |equal-roundtrip ~any = {
    $var.orig = {name="Joe" score=25}
    $var.pyobj = [$var.orig |push/py]
    $var.back = [$var.pyobj |pull/py]
    $var.back $var.orig
}


; Lookup a qualified attribute and ensure fields are present
!func |assert-lookup-attr ~any = {
    $var.info = [{} |lookup/py "sys.float_info.epsilon"]
    ; Expect a type string and a repr string, and a value field with the actual Python object
    $var.ok1 = $var.info.type == "builtins.float"
    $var.ok2 = $var.info.repr != ""
    $var.ok3 = $var.info.value != {}
    $var.ok1 && $var.ok2 && $var.ok3
}


; Call a qualified function and verify result via method and pull
!func |xassert-call-function-urlparse ~any = {
    $var.res = [{url="http://example.com/a?x=1"} |call-func/py "urllib.parse.urlparse"]
    $var.url = [$var.res |call/py "geturl"]
    $var.urlstr = [$var.url |pull/py]
    $var.urlstr == "http://example.com/a?x=1"
}


; Call a method on a Python object produced from a Comp value
!func |xassert-call-method-lower ~any = {
    $var.pystr = ["Hello" |push/py]
    $var.lower = [$var.pystr |call/py "lower"]
    $var.result = [$var.lower |pull/py]
    $var.result == "hello"
}


; Build a structure from a Python object using vars
!func |assert-vars ~any = {
    $var.ns = [{foo=1 bar="a"} |call-func/py "types.SimpleNamespace"]
    $var.struct = [$var.ns |vars/py]
    $var.struct.foo == 1 && $var.struct.bar == "a"
}


