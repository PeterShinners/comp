!import /text = comp "text"


!func |equal-upper ~any = {
    ["Hello" |uppercase] "HELLO"
}

!func |equal-lower ~any = {
    ["Hello" |lowercase] "hello"
}

!func |equal-trim-plain ~any = {
    ["  shave " |trim] "shave"
}

!func |equal-trim-end ~any = {
    ["  shave " |trim #end] "  shave"
}

!func |equal-trim-end ~any = {
    ["..shave?" |trim ".?" #start] "shave."
}

!func |equal-trim-full ~any = {
    ["shave" |trim "shave"] ""
}

!func |equal-trim-full ~any = {
    ["shave" |trim "shave"] ""
}

!func |assert-empty ~any = {
    ["" |empty?]
}

!func |assert-not-empty ~any = {
    !! ["hello" |empty?]
}

!func |assert-blank ~any = {
    ["   " |blank?]
}

!func |assert-not-blank ~any = {
    !! ["  hello\n" |blank?]
}

!func |assert-numeric ~any = {
    ["123" |numeric?]
}

!func |assert-not-numeric ~any = {
    !! ["12a3" |numeric?]
}

!func |assert-alpha ~any = {
    ["hello" |alpha?]
}

!func |assert-not-alpha ~any = {
    !! ["hello123" |alpha?]
}

!func |assert-alphanumeric ~any = {
    ["hello123" |alphanumeric?]
}

!func |assert-not-alphanumeric ~any = {
    !! ["hello 123" |alphanumeric?]
}

!func |assert-lowercase ~any = {
    ["hello" |lowercase?]
}

!func |assert-not-lowercase ~any = {
    !! ["Hello" |lowercase?]
}

!func |assert-uppercase ~any = {
    ["HELLO" |uppercase?]
}

!func |assert-not-uppercase ~any = {
    !! ["Hello" |uppercase?]
}

!func |assert-contains ~any = {
    ["hello world" |contains? "world"]
}

!func |assert-not-contains ~any = {
    !! ["hello world" |contains? "Wor"]
}

!func |assert-contains-insensitive ~any = {
    ["hello world" |contains? "Wor" #insensitive]
}

!func |equal-length ~any = {
    [" Alpha" |length/text] 6  ; builtin function getting dispatch priority? (wrong)
}

!func |equal-length-empty ~any = {
    ["" |length/text] 0
}


; TODO: Fix value unwrapping for split/join - results are triple-wrapped {0: {0: {0: ...}}}
!func |equal-split-whitespace ~any = {
    ["hello world test" |split] {"hello" "world" "test"}
}

!func |equal-split-separator ~any = {
    ["a,b,c" |split split=","] {"a" "b" "c"}
}

!func |equal-split-limit ~any = {
    ["a b c d" |split limit=2] {"a" "b" "c d"}  ; TODO: implement limit parameter
}

!func |equal-split-end ~any = {
    ["a b c d" |split limit=2 target=#end] {"a b c" "d"}  ; TODO: implement limit parameter
}

!func |equal-join-empty ~any = {
    [{"hello" "world"} |join] "helloworld"
}

!func |equal-join-separator ~any = {
    [{hello world} |join separator=", "] "hello, world"
}

!func |equal-reverse ~any = {
    ["hello" |reverse] "olleh"
}

!func |equal-reverse-empty ~any = {
    ["" |reverse] ""
}

!func |equal-repeat ~any = {
    ["ab" |repeat count=3] "ababab"
}

!func |equal-repeat-zero ~any = {
    ["hello" |repeat count=0] ""
}

!func |equal-slice-basic ~any = {
    ["hello" |slice start=1 end=4] "ell"
}

!func |equal-slice-start-only ~any = {
    ["hello" |slice start=2] "llo"
}

!func |equal-slice-end-only ~any = {
    ["hello" |slice end=3] "hel"
}


