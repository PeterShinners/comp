/**
URL shortener service
A simple URL shortener using Redis for storage.
*/

!import http {comp "http-server"}
!import redis {comp "redis"}
!import url {comp "core/url"}
!import template {comp "core/template"}

!package name "shortly"
!package version "1.0.0"


!shape details ~{
    id~text 
    target~text 
    clicks~num = 0
}


/// Module configuration, overridable at startup
!mod server.static "./static"
!mod server.templates "./templates"
!mod redis {host="localhost" port=6379}
!mod keys {
    target = "url-target:%()"
    counter = "click-count:%()"
    reverse = "reverse-url:%()"
    total = "last-url-id"
}


!context web {
    redis-db = redis.connection
}


!startup web (
    $ 
    | dispatch
    | post --"/" (link-create)
    | get --"/" (response-template --"newurl.html")
    | get --"/{id}" (link-redirect)
    | get --"/{id}.json" (link-details)
    | missing (response-template --"404.html" --status=404)
    //x or perhaps something with an `!on` here?
)


/// Accept a URL submission and redirect to its detail page
!func link-create ~http.request (
    $form.url
    unless --$ | url.parse | $scheme | in --{"http" "https"}) (
        {error="Please enter a valid URL" url=$$form.url}
        | response-template --"newurl.html"
    )
    | insert-url
    | http.redirect --"/%($id).json"
)


/// Redirect short URL to its target, incrementing click count
!func link-redirect ~http.request (
    $params.id | fetch-details | increment
    http.redirect --$target
)


/// Render detail page for a short URL
!func link-details ~http.request (
    $params.id | fetch-details | response-json
)


/// Look up or create a short URL entry
!func insert-url text (
    $ | fmt --mod.keys.reverse
    | redis.get
    | if-nil --(
        !let id mod.keys.total | redis.incr | base36-encode
        {
            'id | fmt --mod.keys.target' = $$
            'id | fmt --mod.keys.counter' = 1
            '$$ | fmt --mod.keys.reverse' = id
            //x the single quote field expression needs to be ok for pipelines            
        }
        | redis.mset
        id
    )
    response-redirect --@fmt"/%().json"
)


/// Fetch details for a short URL id
!func fetch-details
{
    !input ~text

    {
        target = $ | fmt --mod.keys.target
        clicks = $ | fmt --mod.keys.counter
    }
    | redis.mget
    | defaults --clicks=0
}


/// Increment the click counter for a URL
!func increment ~details ( 
    $id 
    | fmt --mod.keys.counter
    | redis.incr
)


/// Encode a number in base36
!pure base36-encode ~num (
    !let charset "0123456789abcdefghijklmnopqrstuvwxyz"
    !let result ""
    !let n $

    n | while --($ > 0
        !let div $ | divmod --(charset | length)
        !let result (charset | char-at-index --div.remainder) | join result
        div.quotient
    )
    //x so `while` pipes the resulting value back to itself (sort of like a reduce?)
    //x seems cool actually, unless there's a better abstraction somewhere else?

    $result | if-empty --(charset | first)
)
