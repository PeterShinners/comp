/**
URL shortener service
A simple URL shortener using Redis for storage.
*/

!import http {comp "http-server"}
!import redis {comp "redis"}
!import url {comp "core/url"}
!import template {comp "core/template"}

!package name "shortly"
!package version "1.0.0"


/** mod values are constant
these can only ever be seen by the current module, private data
can be overridden at startup (.env files, args, whatever)
*/
!mod server.static "./static"
!mod server.templates "./templates"
!mod redis {host="localhost" port=6379}
!mod keys {
    target = "url-target:$()"
    counter = "click-count:$()"
    reverse = "reverse-url:$()"
    total = "last-url-id"
}


!context web = {:
	// automatic default to functions with a `db` modifier of this shape
	redis-db = |> redis.connection 
}



!main web :req~http.request (|val
    req 
    -> dispatch
    -> post["/"] (:> post-url)
    -> get["/"] (:> forward-url)
    -> get["/"] (:> response-template["newurl.html"])
    -> get["/{id}"] (:> link-redirect)
    -> get["/{id}.json"] (:> link-details)
    -> missing (:> response-template["404.html" status=404])
)


!shape details ~(:id~text
	target = id -> format[mod.keys.target] -> redis.get
	clicks = id -> format[mod.keys.counter] -> redis.get -> defaults[0]
)


!func increment (:details~details
	details.id -> format[mod.keys.counter] -> redis.incr
)


!func insert-url (:url~text
	url
	-> format[mod.keys.reverse]
	-> redis.get
	-> if-empty (:
		!let id = mod.keys.total -> redis.incr -> base36-encode
		{
			(id -> format[mod.keys.target]) = url
			(id -> format[mod.keys.counter]) = 1
			(url -> format[mod.keys.reverse]) = id
		}
		-> redis.mset
		id
	)
)


!func post-url (:request~http.request
    request.form.url
    -> assert (parse(url).scheme -> in["http" "https"] :(
        {error="Please enter a valid URL" url=request.form.url}
        -> respond-template "newurl.html"
    ))
    -> insert-url
    -> format "/$(id).json"
    -> http.redirect()
)


!func link-redirect (:request~http.request
    request.params.id
    -> details()
    -> increment()
    -> (in.target)  // this needs some language definition
    -> http.redirect()
    // ?> respond-missing()
)


!func link-details (:req~http.request
    req.params.id
    -> details
    -> render["details.html"]
    // ?> respond-missing()
)


!shape details ~{
    id~text
    target~text
    clicks~num = 0
}


!func details (:<mix :id~text 
    id = id
    (
        target = id -> format[mod.keys.target]
        clicks = id -> format[mod.keys.counter]
    )
    -> redis.mget
    -> defaults[clicks=0]
)



!func base36-encode (:num~num :pure 
	!let charset = "0123456789abcdefghijklmnopqrstuvwxyz"
	!let result = ""
	!let n = num
	n -> while (:n n > 0) (:n
		!let div = n -> divmod[charset -> length]
		!let letter = charset -> char[div.remainder]
		result => join[letter result]
		n => div.division
	)
	result -> if-empty :(charset -> letters -> first)
)
