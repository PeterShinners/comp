/**
URL shortener service
A simple URL shortener using Redis for storage.
*/

!import http {comp "http-server"}
!import redis {comp "redis"}
!import url {comp "core/url"}
!import template {comp "core/template"}

!package name "shortly"
!package version "1.0.0"


!shape link ~{id~text target~text clicks~num = 0}


/// Module configuration, overridable at startup
!mod server.static "./static"
!mod server.templates "./templates"
!mod redis {host="localhost" port=6379}
!mod keys {
    target = "url-target:$()"
    counter = "click-count:$()"
    reverse = "reverse-url:$()"
    total = "last-url-id"
}


!context web {
    redis-db = redis.connection
}


!startup web
(|
    dispatch
    | post "/" 
    (| link-create)
    | get "/" 
    (| response-template "newurl.html")
    | get "/{id}" 
    (| link-redirect)
    | get "/{id}.json" 
    (| link-details)
    | missing 
    (| response-template "404.html" status=404)
)


/// Accept a URL submission and redirect to its detail page
!func link-create
@input ~http.request
(|
    $.form.url
    | assert (| url.parse $.scheme | in {"http" "https"})
    (|
        {error="Please enter a valid URL" url=$$.form.url}
        | response-template "newurl.html"
    )
    | insert-url
    | http.redirect "/$($.id).json"
)


/// Redirect short URL to its target, incrementing click count
!func link-redirect
@input ~http.request
(|
    $.params.id
    | fetch-details
    | increment
    http.redirect $.target  //x this is 2 statements, an error
)


/// Render detail page for a short URL
!func link-details
@input ~http.request
(|
    $.params.id
    | fetch-details
    | response-json
)


/// Look up or create a short URL entry
!func insert-url
@input ~text
(|
    format mod.keys.reverse
    | redis.get
    | if-nil
    (|
        $id = mod.keys.total | redis.incr | base36-encode
        {
            '$id | format mod.keys.target' = $$
            '$id | format mod.keys.counter' = 1
            '$$ | format mod.keys.reverse' = $id
            //x the single quote field expression needs to be ok for pipelines
        }
        | redis.mset
        $id  //x one again a second statement, what to do about this?
    )
)


/// Fetch details for a short URL id
!func fetch-details
@input ~text
{|
    details id=$
    | redis.mget {
        target = ($.id | format mod.keys.target)
        clicks = ($.id | format mod.keys.counter)
    }
    | defaults clicks=0
}


/// Increment the click counter for a URL
!func increment
@input ~details
(| 
    $.id 
    | format mod.keys.counter 
    | redis.incr
)


/// Encode a number in base36
!func base36-encode
@input ~num @pure
(|
    $charset = "0123456789abcdefghijklmnopqrstuvwxyz"
    $result = ""
    $n = $

    $n | while (| $ > 0)  //x why isn't this block on a separate line?
    (|
        $div = $ | divmod ($charset | length)
        $result = {$charset | char-at-index $div.remainder} | join $result
        $div.quotient
    )

    $result | if-empty (| $charset | first)
)
