!mod.doc = """Cloudflare Worker for vector embeddings and search

Original: https://developers.cloudflare.com/vectorize/get-started/embeddings/
"""

!import url stdlib "core/urllib"
!import cf comp "github://cloudflare/workers-comp@2.7/complib"

!mod.model = "@cf/baai/bge-base-en-v1.5"


!context default = ({
	; These values for !ctx require dynamic computation
	vectorize = "VECTORIZE" -> binding()
	ai = "AI" -> binding()
})


!func fetch = (
	@call = {}
	@arg = {request = request}
	@doc = "Map request urls to handlers and respond to errors"

	!arg.request.url
	-> parse()
	-> dispatch(
		; These assignments have an ambiguity with destructured assignment, error
		(#get "/favicon*") = #not-found.response
		(#post "/insert") = insert-vectors
		else = query-vectors
	)
	->? {
		body = !in $ "Request processing failed: ${!in.message}"
		status = !in.status ?? #server-error
	}
	-> response-json()
)


!func insert-vectors = (
	@call = {}
	@arg = {model = str  ai = vector-datasource}
	@doc = "Only need to generate vector embeddings once (or as data changes)"

	(  ; A real application would read initial data from db or r2
		"This is a story about an orange cloud"
		"This is a story about a llama"
		"This is a story about a hugging emoji"
	)
	-> map() => {
		text = !in
		{model ai} = !arg
	}
	-> ai-run()
	-> iter() => {
		id = !in $ "${index}"
		values = !in.value.embedding
	}
	-> vectorize-upsert()
)


!func query-vectors = (
	@call = {text = str @default = "orange cloud"}
	@arg = {model = str  ai = vector-datasource}
	@doc = "Find closest match to query string"

	!in
		-> ai-run()
		-> vectorize-query(topK=1)

	; Expect vector ID 1 to be your top match with a score of ~0.89693683
	; This tutorial uses a cosine distance metric, where the closer to one,
	; the more similar.
)
