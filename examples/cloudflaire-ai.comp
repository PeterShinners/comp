// Cloudflare Worker for vector embeddings and search
// Original: https://developers.cloudflare.com/vectorize/get-started/embeddings/

$app.model = "@cf/baai/bge-base-en-v1.5"
$app.VECTORIZE = <hint: ~cloudflare~vec_handle>  // hypothetical syntax
$app.AI = <hint: ~cloudflare~ai_handle>  // hypothetical syntax

$app.dependencies = {
    cloudflare: "@cloudflare/workers-comp@2.7/comp"
}

!entry = {
    $app.VECTORIZE = :cloudflare:binding("VECTORIZE")
    $app.AI = :cloudflare:binding("AI")
}

!shape VectorizeVector = {
    id ~string
    values ~{number[1-]}
}

!func fetch ~:cloudflare:Request = {
    url -> :url:parse -> :url:dispatch
        ."/favicon*" {:cloudflare:response_not_found}
        ."/insert" {:insert_vectors}
        .else {:query_vectors}
    !> {
        error = "Request processing failed: ${error.message}"
        status = status | 500
    }
    -> :cloudflare:response_json
}

// You only need to generate vector embeddings once (or as
// data changes), not on every request
!func insert_vectors = {
    // In a real-world application, you could read content from R2 or
    // a SQL database (like D1) and pass it to Workers AI
    $stories = {
        "This is a story about an orange cloud"
        "This is a story about a llama" 
        "This is a story about a hugging emoji"
    }

    // Direct invocation of AI binding with model configuration
    {model=$app.model text=$stories}
    -> :cloudflare:ai_run
    -> .data -> :enumerate 
    => {index, value -> {id="${index}" values=value}}
    -> VECTORIZE($in ~VectorizeVector)
    -> :cloudflare:vectorize_upsert
}

!func query_vectors = {
    // Your query: expect this to match vector ID. 1 in this example
    $user_query = "orange cloud"
    
    {model=$app.model text=$user_query}
    -> :cloudflare:ai_run
    -> .data.'0'
    -> VECTORIZE({topK=1})
    -> :cloudflare:vectorize_query
    -> {matches=$in}

    // Expect a vector ID. 1 to be your top match with a score of
    // ~0.89693683
    // This tutorial uses a cosine distance metric, where the closer to one,
    // the more similar.
}



/*  TypeScript version of the above Cloudflare Worker example */
export interface Env {
  VECTORIZE: Vectorize;
  AI: Ai;
}
interface EmbeddingResponse {
  shape: number[];
  data: number[][];
}

export default {
  async fetch(request, env, ctx): Promise<Response> {
    let path = new URL(request.url).pathname;
    if (path.startsWith("/favicon")) {
      return new Response("", { status: 404 });
    }

    // You only need to generate vector embeddings once (or as
    // data changes), not on every request
    if (path === "/insert") {
      // In a real-world application, you could read content from R2 or
      // a SQL database (like D1) and pass it to Workers AI
      const stories = [
        "This is a story about an orange cloud",
        "This is a story about a llama",
        "This is a story about a hugging emoji",
      ];
      const modelResp: EmbeddingResponse = await env.AI.run(
        "@cf/baai/bge-base-en-v1.5",
        {
          text: stories,
        },
      );

      // Convert the vector embeddings into a format Vectorize can accept.
      // Each vector needs an ID, a value (the vector) and optional metadata.
      // In a real application, your ID would be bound to the ID of the source
      // document.
      let vectors: VectorizeVector[] = [];
      let id = 1;
      modelResp.data.forEach((vector) => {
        vectors.push({ id: `${id}`, values: vector });
        id++;
      });

      let inserted = await env.VECTORIZE.upsert(vectors);
      return Response.json(inserted);
    }

    // Your query: expect this to match vector ID. 1 in this example
    let userQuery = "orange cloud";
    const queryVector: EmbeddingResponse = await env.AI.run(
      "@cf/baai/bge-base-en-v1.5",
      {
        text: [userQuery],
      },
    );

    let matches = await env.VECTORIZE.query(queryVector.data[0], {
      topK: 1,
    });
    return Response.json({
      // Expect a vector ID. 1 to be your top match with a score of
      // ~0.89693683
      // This tutorial uses a cosine distance metric, where the closer to one,
      // the more similar.
      matches: matches,
    });
  },
} satisfies ExportedHandler<Env>;