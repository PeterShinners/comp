mod.doc: """Cloudflare Worker for vector embeddings and search

Original: https://developers.cloudflare.com/vectorize/get-started/embeddings/
"""

!import url stdlib "core/urllib"
!import cf comp "github://cloudflare/workers-comp@2.7/complib"

mod.model: "@cf/baai/bge-base-en-v1.5"


!context ~{
	; These values must be computed, can't be part of static module
	.ctx.vectorize: "VECTORIZE" -> binding/cf
	.ctx.ai: "AI" -> binding/cf
}


fetch: ~[
	.arg.request.url 
	-> parse/url()
	-> dispatch/url(
		; These assignments have an ambiguity with destructured assignment, error
		(#get "/favicon*"): #not-found.response
		(#post "/insert"): insert-vectors
		else: query-vectors
	)
	->? {
		body: .in $ "Request processing failed: ${.in.message}"
		status: .in.status ?? #server-error
	}
	-> response-json
]
@call: {}
@arg: {request: request/cf}
@doc: "Map request urls to handlers and respond to errors"


insert-vectors: ~[
	(  ; A real application would read initial data from db or r2
		"This is a story about an orange cloud"
		"This is a story about a llama" 
		"This is a story about a hugging emoji"
	)
	-> map({
		text: .in
		(model ai): .arg
	})
	-> ai-run()
	-> iter(~{
		id: .in $ "${index}"
		values: .in.value.embedding
	}) 
	-> vectorize-upsert()
]
@call: {}
@arg: {model: str ai: vector-datasource/cf}
@doc: "Only need to generate vector embeddings once (or as data changes)"


query-vectors: ~[
	.in
	-> ai-run()
	-> vectorize-query(topK:1)

	; Expect vector ID 1 to be your top match with a score of ~0.89693683
	; This tutorial uses a cosine distance metric, where the closer to one,
	; the more similar.
]
@call: {text: str @default: "orange cloud"}
@arg: {model: str ai: vector-datasource/cf}
@doc: "Find closest match to query string"

