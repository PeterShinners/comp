/**
Pygame chimp tutorial example
Punch a monkey to win prizes.

Demonstrates event dispatch, animation, and game loop
using shape-based function overloading.

- Game state is an immutable shape, each frame produces a new state rather than
  mutating in place
- Event handlers are overloaded on `~pg.event` shape with different type
  constraints, dispatch replaces the typical event type switch statement
- `@update` on handlers means each one only returns the fields that changed, the
  engine merges them onto the existing state
- `pick` maps a boolean to one of two values, replaces ternary operators

*/

!import pg comp "pygame-comp-spectacular@1.0.4"


!shape state ~{
    bgd~pg.card
    fist~pg.card
    chimp~pg.card
}


!startup game (
    !let window 
	pg.display
	| window :{1280 480} :scaled
	| caption :"Monkey Fever"
	| mouse-visible :false

    !let state {
        bgd = pg.card :window.size :fill={0.7 0.9 0.7}
        fist = pg.card :res.fist :pivot={235 80}
        chimp = pg.card :res.chimp :pivot=center
    }

    pg.loop :window :quit-on={event.quit key.escape} :(
		!arg state~state // loop sets this up as context?

        $events 
		| each[handle]

		$draw
        | clear :{0.7 0.9 0.7}
        | draw-cards :{state.chimp state.fist}
	)
)


/// Handle mouse down: punch and check for hit
!func handle ~pg.event @update(
    :param state~state

    $type ?? mouse.down | else (pass)

    !on {state.fist state.chimp} | intersect :overlap=5
    ~true {
        chimp.rotate = (state.chimp.rotate | spin :360 :0.5 :ease-out)
        chimp.translate.x = (state.chimp.translate.x | update :after=chimp.rotate)
        commands = {audio.play :res.punch}
    }
    ~false {
        commands = {audio.play :res.whiff}
    }
)


/// Handle mouse up: retract fist
!func handle pg.event[type==mouse.up] (
	//x how to make value based types from fields like this?
	:param state~state

	state.fist | move :{-10 -90}
)

//x note, realistically these handlers want take state as input and event as a modifier
// that could be ok if there was a function that dispatched based on modifiers
// instead of the input shape?


/// Handle mouse move: track fist position
!func handle ~pg.even[type==mouse.move] (
	:param state~state
	
	state.fist | position :$position
)
