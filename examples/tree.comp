/// 
Binary search tree example
Operations for a minimal binary tree

- Overloaded dispatch to handle empty branches

///

!shape tree = ~{value~num left~branch right~branch}
!shape branch = ~tree|nil = nil


!startup main (:
	(5 3 8 1 7 9)
	-> reduce[initial] [:> tree tree-insert]
	-> tree-values
	-> print
)


// Add new value into tree
!func tree-insert (:t~nil :value~num :pure
	|> tree[value]
)
!func tree-insert {:<update :t~tree :value~num :pure
	value < t.value
	-> when {:
		left = t.left => tree-insert[value]
	} {:
		right = t.right => tree-insert[value]
	}
}


// Check if tree contains value
!func tree-contains (:t~nil :value~num :pure
	false
)
!func tree-contains {:<update :t~tree :value~num :pure

	-> if [value < t.value] (:v t.left -> tree-contains[value])
	-> elif (:v value > t.value) (:v t.right -> tree-contains[value])
	-> else (:v true)
}


// Iterate values from tree in order
!func tree-values (:t~nil :pure 
	()
)
!func tree-values (:<flat :t~tree :pure 
	t.left -> tree-values
	{t.value}
	t.right -> tree-values
)
