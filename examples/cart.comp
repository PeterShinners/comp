/** 
Shopping cart module
Define several simplistic shapes and modification functions to manage
the contents of a shopping cart.

Highlights:

- Entire module compiles to a single constant output statement, all functions 
  are pure and all inputs are literals, so the compiler folds everything at 
  build time 
- `upsert` combines replace with `else` fallback to express "update or insert"
  as a single pipeline
- Shape constructors like `item` and `cart` work as pipeline functions, data
  flows through them for validation and morphing, no new keyword
- `@update` wrapper on `upsert` means it only needs to return changed fields,
  not rebuild the full collection

*/

!import stdloop comp "loop"
!import stdstruct comp "struct"

!shape item ~{name~text price~num quantity~num=1}
!shape cart ~{items~item* discount~num=0}

!startup main (
    {
        {"Apple" price=1.00}
        {"Banana" price=0.50 quantity=2}
        {"Apple" 1.00 quantity=2}  // replaces previous apples
    }
    | map :(item)  // morph each simple structure into a full cart item
    | reduce :(upsert :($.name))
    | cart :discount=0.2
    | total
    | output :"Total: %()"
)

!pure total ~cart ( 
    $.items | sum :($.price * $.quantity) * (1 - $.discount)
    // Operator precedence applies the final multiplication to the sum
)

/// Insert or update an item in a collection
!pure upsert ~any* (
    :param item ~item
    :block key ~item = pass

    $ | replace :limit=1 :key :item | else :(append :item)
)
