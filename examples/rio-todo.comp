; Reactive Todo app with immutable state
import rio from "@gh/rio-dev/rio-comp"

shape todo {
    title string
    complete bool = false
    id uuid = gen_uuid
}

shape state {
    todos [todo] = []
    input string = ""
    filter #visibility = #all
}

tag visibility = #all | #active | #complete

; Main app - Rio handles the reactive loop
main (
    rio.app title="Todo" state=state{} root=todo_app
)

; Build the UI declaratively
todo_app state (
    #column spacing=2 {
        ; Stats bar
        stats state
        
        ; Input field  
        #row {
            #text_input text=state.input 
                       placeholder="What needs doing?"
                       flex=1
                       on_change={value} (state with {input=value})
                       on_submit (add_todo state)
            
            #button text="Add" 
                   disabled=(state.input == "")
                   on_click (add_todo state)
        }
        
        ; Todo list
        state.todos -> filter_by state.filter
                   -> each todo_item state
        
        ; Filter buttons
        #row {
            [#all #active #complete] -> each filter {
                #button text=filter 
                       variant=(when state.filter == filter "primary" else "outline")
                       on_click (state with {filter})
            }
        }
    }
)

; Individual todo item
todo_item todo state (
    #row align="center" {
        #checkbox checked=todo.complete 
                 on_change (toggle_todo state todo.id)
        
        #text text=todo.title 
             flex=1
             style=(when todo.complete "strikethrough")
        
        #icon_button icon="delete" 
                    on_click (delete_todo state todo.id)
    }
)

; Stats display
stats state (
    active = state.todos -> count not .complete
    
    #card {
        #text "ðŸ“‹ {active} of {state.todos.length} remaining" size="large"
    }
)

; State updates (pure functions)
add_todo state (
    when state.input.trim != "" (
        state with {
            input = ""
            todos = state.todos ++ [{title=state.input}]
        }
    ) else (state)
)

toggle_todo state id (
    state with {
        todos = state.todos -> map t (
            when t.id == id (t with {complete = not t.complete})
            else (t)
        )
    }
)

delete_todo state id (
    state with {todos = state.todos -> keep {.id != id}}
)

filter_by todos filter (
    match_shape filter
        #all (todos)
        #active (todos -> keep not .complete)
        #complete (todos -> keep .complete)
)