Classic Todo app using UI library
Based on migration from Rio library for Python
---

import.rio = ("@gh/rio-dev/rio-comp" comp)


context.rio = (
	title = "Todo"
	state = state ()
	component = todo-app
)


todo = ~(
	title~string
	complete~bool = false
	id~id  ; auto unique value on construction (not a number or string)
)


state = ~(
	todos~todo[] = []
	input~text = ""
	filter~visibility = all
)

visibility.all = tag()
visibility.active = tag()
visibility.complete = tag()


todo-app = :state~state (
	Build app window component declaratively
	---
	component.column spacing=2 (|mix
		; Input field  
		component.row(
			component.text-input 
			text = state.input 
			placeholder = "What needs doing?"
			flex = 1
			on-change = : (it |merge (input=value))
			on-submit = add-todo
			
			component.button 
			text = "Add" 
			disabled = (state.input |trim() == "")
			on-click = add-todo
		)
		
		; Todo list
		state.todos
		|filter : (todo-visible(state.filter))
		|map : (todo-item (state it))
		
		; Filter buttons
		component.row(all active complete) |map :it (
			component.button
			text = it.filter ~text
			variant = pick(it == state.filter "primary" "outline")
			on-click = :it (state .. (filter=it))
		) |flatten()
	)
)


todo-item = :args~(state~state todo~todo)(
	Build individual todo item component declaratively
	---
	component.row align=center(
		component.checkbox 
		checked = todo.complete 
		on-change = : (|val toggle-todo(state todo.id))
		
		component.text 
		text = todo.title 
		flex = 1
		style = pick(todo.complete "strikethrough" nil)
		
		component.icon-button 
		icon = "delete" 
		on-click = : (|val delete-todo(state todo.id))
	)
)


add-todo = :state~state (|mix
	Create new todo from current applications state
	---
	var.title = state.input |trim() |if-empty("<no name>")
	state 
	todos = state.todos |extend(var.title ~todo)
)


toggle-todo = :state~state id~id (|mix
	Toggle todo complete status
	---
	state
	todos = state.todos |map :it (|mix
		it 
		complete = pick (|val it.id == args.id !!it.complete it.complete)
	)
)


delete-todo = :state~state id~id (|mix
	Remove item from applicate state
	---
	state
	todos = state.todos |filter :it (it.id != args.id)
)


todo-visible = :todo~todo filter~filter (|val
	Determine if an item should be visible based on filter
	---
	filter |case(
		'all' = true
		'active' = !!todo.complete
		'complete' = todo.complete
	)
)
