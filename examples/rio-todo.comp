---
TODO app using Rio UI library
Based on migration from Rio library for Python


my thoughts based on initial port
- the spread operator is nasty in callbacks
  `on_click = :({(..)=state filter=it})`
- callbacks usually just a block that wraps a func with args that feels syntaxy
  `on_clock = :(delete_todo (state todo.id))`
- new 'id' type has automatic default computed value
  - this seems like a language feature emerging
		- don't want this to feel like class constructors - eeek
---

import rio comp "@gh/rio-dev/rio-comp"


shape ~todo {
	title ~string
	complete ~bool = false
	id ~id  -- auto unique value on construction (not a number or string)
}

shape ~state {
	todos ~todo[] = []
	input ~str = ""
	filter #visibility = #all
}

tag #visibility tag_value_name {#all | #active | #complete}


context rio {
	title = "Todo" 
	state = ~state ()
	component = todo_app
}


-- Build app window component declaratively
func todo_app state ~state ({
	#column spacing=2 {
		; Input field  
		#row {
			#text_input 
			text = state.input 
			placeholder = "What needs doing?"
			flex = 1
			on_change = :({(..)=it input=value})
			on_submit = add_todo
			
			#button 
			text = "Add" 
			disabled = (state.input | trim () == "")
			on_click = add_todo
		}
		
		; Todo list
		(..) = state.todos
		| filter :(todo_visible (state.filter))
		| map :(todo_item (state it))
		
		; Filter buttons
		#row
			{#all #active #complete} | each :({
				#button
				text = it.filter ~str
				variant = (if (it == state.filter "primary") | else ("outline"))
				on_click = :({(..)=state filter=it})
			}) 
			| flatten ()
	}
})


-- Build individual todo item component declaratively
pure func todo_item ~nil args ~{state ~state todo ~todo} ({
	#row align="center" {
		#checkbox 
		checked = todo.complete 
		on_change = :(toggle_todo (state todo.id))
		
		#text 
		text = todo.title 
		flex = 1
		style = if (todo.complete "strikethrough")
		
		#icon_button 
		icon = "delete" 
		on_click = :(delete_todo (state todo.id))
	}
})


-- Create new todo from current applications state
pure func add_todo state ~state (
	let name = state.input | trim () | if ((in | empty ()) "<no name>")
	{
		(..) = state
		todos = state.todos | append (title ~todo)
	}
)


-- Toggle todo complete status
pure func toggle_todo state ~state args ~{id ~id} ({
	(..) = state
	todos = state.todos | map :({
		(..) = it
		complete = if (it.id == args.id !!it.complete it.complete)
	})
})


-- Remove item from applicate state
pure func delete_todo state ~state args ~{id ~id} ({
	(..) = state
	todos = state.todos | filter :(it.id == args.id)
})


-- Determine if an item should be visible based on filter
pure func todo_visible todo ~todo args ~{filter #filter} (
	switch (args.filter {
		#all -> #true
		#active -> !!it.complete
		#complete -> it.complete
	})
)
