/**
Classic Todo app using a declarative UI library.
Based on migration from Rio library for Python.

Highlights:

- UI components are struct literals, the entire view is data describing layout,
  not imperative widget construction
- `!context state $` makes the current state available to all downstream
  functions without laborious argument passing.
- `@update` on mutation functions means `toggle-todo` only specifies `{complete
  = ...}`, everything else passes through unchanged
- Visibility filtering uses tag dispatch, `!on filter` with `~all`, `~active`,
  `~complete` branches, no string comparisons

*/

!import rio {comp "@gh/rio-dev/rio-comp"}


!shape todo ~{
    title~text
    complete~bool = false
    id~id
}

!shape state ~{
    todos~todo{} = {}
    input~text = ""
    filter~visibility = all
}

!tag visibility {all active complete}


!startup rio {
    title = "Todo"
    state = state
    component = todo-app
}


/// Build app window component declaratively
!func todo-app ~state (
    !context state $

    rio.column :spacing=2 :{
        rio.row :{
            rio.text-input :{
                text = $input
                placeholder = "What needs doing?"
                flex = 1
                on-change = merge :input=$value]
                on-submit = add-todo
            }
            rio.button :{
                text = "Add"
                disabled = ($input | trim | empty)
                on-click = add-todo
            }
        }

        $todos
        | where :(todo-visible[filter=$$filter])
        | map :(todo-item)

        rio.row :{
            {all active complete}
            | map :(
                rio.button[
                    text = ($ | to-text)
                    variant = ($ == $$filter | pick :{"primary" "outline"})
                    on-click = (merge :filter=$)
                ]
            )
        }
    }
)


/// Build individual todo item component
!func todo-item ~todo (
    rio.row :align=center :{
        rio.checkbox :{
            checked = $complete
            on-change = (toggle-todo :$id)
        ]
        rio.text :{
            text = $title
            flex = 1
            style = ($complete | pick :"strikethrough" :nil)
        }
        rio.icon-button :{
            icon = "delete"
            on-click = (delete-todo :$id)
        }
    }
)


/// Create new todo from current input
!func add-todo ~state @update{
    input = ""
    todos = ($todos | append :(
        todo :title=($input | trim | if-empty :"untitled")
    ))
}

/// Toggle todo complete status
!func toggle-todo state @update(
    :param id~id
    {
        todos = ($todos | map :(
            !on ($id == id)
            ~true @update{complete = (!not $complete)}
            ~false $
        ))
    }
)


/// Remove item from state
!func delete-todo ~state @update{
    :param id~id
    todos = ($todos | where :($id != id))
}


/// Determine if an item should be visible based on filter
!pure todo-visible ~todo (
    :param filter~visibility
    !on filter
    ~all true
    ~active (!not $complete)
    ~complete $complete
)