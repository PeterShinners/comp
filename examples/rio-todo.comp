/// 
Classic Todo app using UI library
Based on migration from Rio library for Python
///

!import rio {comp "@gh/rio-dev/rio-comp"}


!startup rio = {:
	title = "Todo"
	state = |> state
	component = todo-app
}


!shape todo = ~{
	title~string
	complete~bool = false
	id~id  // auto unique value on construction? (not a number or string)
}


!shape state = ~{
	todos~todo{} = ()
	input~text = ""
	filter~visibility = all
}

!tag visibility {all active complete}


// Build app window component declaratively
!func todo-app (:~state
	!ctx state state
	rio.column[spacing=2
		// Input field  
		rio.row[  
			rio.text-input[
				text = state.input 
				placeholder = "What needs doing?"
				flex = 1
				on-change = {:<merge input=value}
				on-submit = add-todo
			]
			rio.button[
				text = "Add" 
				disabled = (: state.input -> trim == "")
				on-click = add-todo
			]
		]
		
		// Todo list
		state.todos
		-> filter (:> todo-visible)
		-> map (:> todo-item)
		
		// Filter radios
		rio.row[
			{all active complete} 
			->map :(<flat :i
				rio.button[
					text = it.filter ~text
					variant = (it == state.filter) -> pick["primary" "outline"]
					on-click = (state | merge(filter=it))
				]
			)
		)
	]
)


// Build individual todo item component declaratively
todo-item = :args~(state~state todo~todo)(
	rio.row align=center(
		rio.checkbox 
		checked = todo.complete 
		on-change = : (|val toggle-todo(state todo.id))
		
		rio.text 
		text = todo.title 
		flex = 1
		style = pick(todo.complete "strikethrough" nil)
		
		rio.icon-button 
		icon = "delete" 
		on-click = : (|val delete-todo(state todo.id))
	)
)


// Create new todo from current applications state
add-todo = :~state (|mix
	!let title = state.input | trim() | if-empty("<no name>")
	state
	todos = state.todos | extend(title ~todo)
)


// Toggle todo complete status
toggle-todo = :~state ~id (|update
	todos = state.todos | map :it (|update
		complete = pick (|val it.id == args.id !!it.complete it.complete)
	)
)


// Remove item from applicate state
delete-todo = :~state ~id (|update
	todos = state.todos |filter :it (it.id != args.id)
)


// Determine if an item should be visible based on filter
todo-visible = :~todo ~filter (|val
	filter | case(
		'all' = true
		'active' = !!todo.complete
		'complete' = todo.complete
	)
)
