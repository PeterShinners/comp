/**
Classic Todo app using a declarative UI library.
Based on migration from Rio library for Python.
*/

!import rio {comp "@gh/rio-dev/rio-comp"}


!shape todo
~{
    title~text
    complete~bool = false
    id~id
}

!shape state
~{
    todos~todo{} = {}
    input~text = ""
    filter~visibility = all
}

!tag visibility {all active complete}


!startup rio {
    title = "Todo"
    state = state
    component = todo-app
}


/// Build app window component declaratively
!func todo-app (
    !input ~state
    !ctx state $

    rio.column[spacing=2] {
        rio.row {
            rio.text-input[
                text=$.input
                placeholder="What needs doing?"
                flex=1
                on-change=(merge[input=$.value])
                on-submit=add-todo
            ]
            rio.button[
                text="Add"
                disabled=($.input | trim | empty?)
                on-click=add-todo
            ]
        }

        $.todos
        | where (todo-visible[filter=$$.filter])
        | map (todo-item)

        rio.row {
            {all active complete}
            | map (
                rio.button[
                    text=($ | to-text)
                    variant=($ == $$.filter | pick["primary" "outline"])
                    on-click=(merge[filter=$])
                ]
            )
        }
    }
)


/// Build individual todo item component
!func todo-item (
    !input ~todo

    rio.row[align=center] {
        rio.checkbox[
            checked=$.complete
            on-change=(toggle-todo[$.id])
        ]
        rio.text[
            text=$.title
            flex=1
            style=($.complete | pick["strikethrough" nil])
        ]
        rio.icon-button[
            icon="delete"
            on-click=(delete-todo[$.id])
        ]
    }
)


/// Create new todo from current input
!func add-todo @update (
    !input ~state
    {
        input = ""
        todos = ($.todos | append (todo[title=($.input | trim | if-empty["untitled"])]))
    }
)


/// Toggle todo complete status
!func toggle-todo @update (
    !input ~state
    !args id~id
    {
        todos = ($.todos | map (
            !on ($.id == id)
            ~true @update {complete = (not $.complete)}
            ~false $
        ))
    }
)


/// Remove item from state
!func delete-todo @update (
    !input ~state
    !args id~id
    {todos = ($.todos | where ($.id != id))}
)


/// Determine if an item should be visible based on filter
!pure todo-visible (
    !input ~todo
    !args filter~visibility

    !on filter
    ~all true
    ~active (not $.complete)
    ~complete $.complete
)