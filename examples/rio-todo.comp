--- Classic Todo app using UI library
Based on migration from Rio library for Python
---

import.rio = ("@gh/rio-dev/rio-comp" comp)


startup.rio = (
	title = "Todo"
	state = state ()
	component = todo-app
)


todo = ~(
	title~string
	complete~bool = false
	id~id  -- auto unique value on construction? (not a number or string)
)


state = ~(
	todos~todo[] = []
	input~text = ""
	filter~visibility = all
)

tag.visibility = ~(all active complete)


-- Build app window component declaratively
todo-app = :state~state (
	component.column spacing=2 (|mix
		-- Input field  
		component.row(  
			component.text-input 
			text = state.input 
			placeholder = "What needs doing?"
			flex = 1
			on-change = :it (it |merge (input=value))
			on-submit = add-todo
			
			component.button 
			text = "Add" 
			disabled = (state.input |trim() == "")
			on-click = add-todo
		)
		
		-- Todo list
		state.todos
		|filter : (todo-visible(state.filter))
		|map : (todo-item (state it))
		
		-- Filter radios
		component.row(all active complete) |map :it (|flat
			component.button
			text = it.filter ~text
			variant = pick(it == state.filter "primary" "outline")
			on-click = :it (state .. (filter=it))
		)
	)
)


-- Build individual todo item component declaratively

todo-item = :args~(state~state todo~todo)(
	component.row align=center(
		component.checkbox 
		checked = todo.complete 
		on-change = : (|val toggle-todo(state todo.id))
		
		component.text 
		text = todo.title 
		flex = 1
		style = pick(todo.complete "strikethrough" nil)
		
		component.icon-button 
		icon = "delete" 
		on-click = : (|val delete-todo(state todo.id))
	)
)


-- Create new todo from current applications state

add-todo = :state~state (|mix
	var.title = state.input |trim() |if-empty("<no name>")
	state 
	todos = state.todos |extend(var.title ~todo)
)


-- Toggle todo complete status

toggle-todo = :state~state id~id (|mix
	state
	todos = state.todos |map :it (|mix
		it 
		complete = pick (|val it.id == args.id !!it.complete it.complete)
	)
)


-- Remove item from applicate state

delete-todo = :state~state id~id (|mix
	state
	todos = state.todos |filter :it (it.id != args.id)
)


-- Determine if an item should be visible based on filter

todo-visible = :todo~todo filter~filter (|val
	filter |case(
		'all' = true
		'active' = !!todo.complete
		'complete' = todo.complete
	)
)
