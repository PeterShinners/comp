--- Lock free parallel stack
Uses atomic swaps to retry while contested
---

!import atomic ("@systems/atomic@1.0.1/lib" comp)


node = ~(
	data~text
	next~(node | nil)
)

stack = ~(
	head~(node | nil)
	atom~atomic.version
)


main = :(
	-- Push some items
	!let stack = ()
	| atomic-push("first")
	| atomic-push("second")
	| atomic-push("third")

	-- Pop them back
	forever :(
		!let stack = atomic-pop(stack)
		| print("Popped: $(head.data)")
		|? field.fail break  -- Stop gracefully when empty
	)
)


-- Add a new string to the stack

atomic-push :~stack arg~text (|val
    stack | retry-exchange : (
        head = node(arg stack.head)
        atom = stack.atom
    )
)


-- Remove item from stack or `fail` if empty

atomic-pop = :~stack (|val
    stack | retry-exchange : (
        head = stack.head.next
        atom = stack.atom
    )
)
