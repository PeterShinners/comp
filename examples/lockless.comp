---
Lock free parallel stack

Uses atomic swaps to retry while contested
---

!import atomic comp "@systems/atomic@1.0.1/lib"

!shape ~node 
{
	data ~str
	next ~node | ~nil
}

!shape ~stack 
{
	head ~node | ~nil = {}
	atom ^version/atomic
}


!entry main
{
	; Push some items
	let stack = {}
	| atomic-push {"first"}
	| atomic-push {"second"}
	| atomic-push {"third"}
	
	; Pop them back
	forever :(
		let stack = stack | pop {}
		| print ("Popped: ${head.data}")
		|? #field.fail #break  ; Stop gracefully when empty
	)
}


-- Add a new string to the stack
!func atomic-push stack ~stack arg ~str 
(
    stack | retry-exchange :{
        head = {arg stack.head} ~node
        atom = stack.atom
    }
)


-- Remove item from stack or #fail if empty
!func pop ~nil arg ~{stack ~stack}
(
    stack | retry-exchange :{
        head = stack.head.next
        atom = stack.atom
    }
)
