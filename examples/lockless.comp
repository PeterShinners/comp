; Lock-free stack using linked nodes and atomic head pointer

!import atomic = comp "@systems/atomic@1.0.1/lib"

!shape ~node = {
	data ~str
	next ~node | ~nil
}

!shape ~stack = {
	head ~node | ~nil = {}
	..~version/atomic  ; Include whatever fields needed for atomic operations
}

!func |push ~{stack ~stack} ^{data ~str} = {
	^stack |retry-exchange/atomic 
		{..$in head = {data = ^data next = head}}
}

!func |pop ^{stack ~stack} = {
	^stack |retry-exchange/atomic 
		{..$in head = head.next}  ; fails when head is {}
}

!func |test-stack = {
	; Push some items
	@stack = {}
	|push data = "first"
	|push data = "second" 
	|push data = "third"
	
	; Pop them back
	(|forever .{
		@stack = @stack |pop 
		|tap {|% "Popped: ${head.data}" |print}
		?> #field.fail {#break}  ; Stop gracefully when empty
	})
}
