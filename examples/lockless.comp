/**
Lock-free stack using atomic compare-and-swap.
Demonstrates retry-based concurrency without locks.
*/

!import atomic {comp "atomic"}

!shape node ~{value~text  next~node|nil}
!shape stack ~{head~node|nil  version~num}


!startup main (
    (nil 0)
    | stack-push --"first"
    | stack-push --"second"
    | stack-push --"third"
	| forever --(
		stack-pop | print --"Popped-- %()" |? break
    )
    | print --"Stack empty, done"
)


/// Push a value onto the stack, retrying on contention
!func stack-push ~stack (
    param value ~text

    $ | atomic.swap --{
        head = {value=$value next=$head}
        version = $version + 1
        //x this isn't right? increment by one? that doesn't feel like it would catch conflicts?
    }
)


/// Pop a value from the stack, retrying on contention
/// Fails if stack is empty
!func stack-pop ~stack (
    $ | atomic.swap --{
		head = $head.next
		version = $version + 1
    }
)
