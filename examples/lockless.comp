--- 
Lock free parallel stack using linked list
Uses atomic swaps to retry while contested

- The atomic-exchange retries the operation as needed
---

!import atomic ("@systems/atomic@1.0.1/lib" comp)


stack = ~{head~node|nil atom~atomic.version}
node = ~{data~text next~node|nil}


main = (:
	-- Push some items (let's add threads here, much cooler)
	!let vals = {atom = |> atomic.new}
	-> atomic-push "first"
	-> atomic-push "second"
	-> atomic-push "third"

	-- Pop them back
	forever [:
		!let vals 
		=> atomic-pop
		-> print "Popped: $()"
		->? field.fail break  -- Stop gracefully when empty
	]
)


-- Add new string to the stack
atomic-push = (:vals~stack arg~text
    vals -> atomic-exchange {:
        head = {data=arg next=stack.head}
        atom = vals.atom
    }
)


-- Remove item from stack or `fail` if empty
atomic-pop = @val (:vals~stack
    vals -> atomic-exchange {:
        head = stack.head.next
        atom = vals.atom
    }
	.data
)
