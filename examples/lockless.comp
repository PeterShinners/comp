/// 
Lock free parallel stack using linked list
Uses atomic swaps to retry while contested

- The atomic-exchange retries the operation as needed
///

!import atomic {comp "@systems/atomic@1.0.1/lib"}


!shape stack ~{head~node|nil atom~atomic.version}
!shape node ~{data~text next~node|nil}


!startup main = (:
	// Push some items (let's add threads here, much cooler)
	!let vals = {atom = |> atomic.new}
	-> atomic-push "first"
	-> atomic-push "second"
	-> atomic-push "third"

	// Pop them back
	forever [:
		!let vals 
		=> atomic-pop
		-> print "Popped: $()"
		->? field.fail break  // Stop gracefully when empty
	]
)


// Add new string to the stack
!func atomic-push (:vals~stack arg~text
    vals -> atomic-exchange {:
        head = {data=arg next=stack.head}
        atom = vals.atom
    }
)


// Remove item from stack or `fail` if empty
!func atomic-pop (:vals~stack
    vals -> atomic-exchange {:
        head = stack.head.next
        atom = vals.atom
    }
	.data
)
