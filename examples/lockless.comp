---
Lock free parallel stack

Uses atomic swaps to retry while contested
---

import atomic comp "@systems/atomic@1.0.1/lib"

shape ~node = {
	data ~str
	next ~node | ~nil
}

shape ~stack = {
	head ~node | ~nil = {}
	atomic ^version/atomic
}


-- Add a new string to the stack
!func |atomic-push stack ~stack arg ~str (
    stack | retry_exchange :({
        head = {arg stack.head} ~node
        atomic = stack.atomic
    })
)


-- Remove item from stack or #fail if empty
!func |pop ^{stack ~stack} = {
    stack | retry_exchange :({
        head = stack.head.next
        atomic = stack.atomic
    })
}


!func |test-stack = {
	; Push some items
	let stack = {}
	|push data = "first"
	|push data = "second" 
	|push data = "third"
	
	; Pop them back
	(|forever :{
		let stack = stack | pop ()
		| print ("Popped: ${head.data}")
		|? #field.fail #break  ; Stop gracefully when empty
	})
}
