; Show local times for distributed team meetings
import datetime from "core/datetime"

shape team_member {
    name string
    tz timezone
    working_hours [hour hour] = [9 17]
}

; Team data
team = [
    {name="andres" tz="America/Guayaquil"}
    {name="fdncred" tz="US/Central"}
    {name="gedge" tz="US/Eastern"}
    {name="jt" tz="NZ"}
    {name="wycats" tz="US/Pacific"}
    {name="kubouch" tz="Europe/Helsinki"}
    {name="elferherrera" tz="Europe/London"}
]

; Show meeting time in everyone's timezone
main time="now" (
    event = when time == "now" (datetime.now)
            else (time -> parse_datetime)
    
    print "Meeting at {event -> format "%Y-%m-%d %H:%M %Z"}"
    print "â”€" * 40
    
    team -> each member {
        member with {
            local = event -> to_timezone member.tz
            hour = local -> hour
            status = when hour in 9..17 ("âœ“") 
                     when hour in 6..22 ("âš ") 
                     else ("ðŸ’¤")
        }
    }
    -> sort {.local.hour}
    -> each m (
        print "{m.status} {m.name:10} {m.local -> format "%H:%M"} {m.tz}"
    )
)

; Find best meeting times across timezones
main #suggest (
    print "Best times for {team.length} people:"
    
    0..23 -> each hour {
        hour_utc = hour -> as_datetime
        available = team -> count member (
            local = hour_utc -> to_timezone member.tz -> hour
            local in 9..17
        )
        {hour available}
    }
    -> keep {.available >= team.length * 0.6}
    -> sort {.available} desc
    -> first 3
    -> each slot (print "  {slot.hour}:00 UTC - {slot.available}/{team.length} available")
)

; Add a new team member
main #add name tz working_start=9 working_end=17 (
    new_member = {name tz working_hours=[working_start working_end]}
    
    team -> append new_member 
         -> save_to "team.comp"
    
    print "Added {name} in {tz}"
)