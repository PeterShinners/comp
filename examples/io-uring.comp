; io_uring file reader using hypothetical Comp uring library
; Compare with: https://unixism.net/loti/liburing_examples.html

!import ring = comp "system:/uring@1.2/uring"
!import fs = stdlib "fs"
!import io = stdlib "io"
!import clib = stdlib "clib"

$mod.QUEUE_DEPTH = 1
$mod.BLOCK_SIZE = 1024

; Library-provided shapes for io_uring operations
!shape ~file-info = {
	size ~number@size.bytes
	blocks ~io-vec[]
}

!func |read-file-async ^{path ~string} = {
	@size = ^path |stat/clib |.size
	@vecs = {@size $mod.BLOCK_SIZE} |alloc-buffers/uring

	@op = {
		op_type = #readv.read.uring_op
		fd = file_descriptor
		io-vecs = @vecs
		offset = 0
	}

	; Submit async read operation
	@ring = (|get-ring/uring)
	@file-info = {size=@. blocks = @vecs}
	@ring |get-sqe/uring
	|prep-readv/uring {
		fd = file_descriptor
		io-vecs = @vecs
		offset = 0
		op_type = #readv.read.uring_op
	} 
	|set-data/uring @file-info
	|submit/uring

	; Wait for completion and process result
	@ring 
	|wait-completion/uring
	|get-data/uring
	|map {
		@buffer = io-vec.base |to-string/buffer {length = io-vec.length}
		@buffer |print
	}
}

!main = {
	@args = (|cmdline/env)
	@args |if length < 2
		.{#fail.process.arguments message="Usage: file_reader paths..."}

	; Initialize io_uring with queue depth
	$mod.QUEUE_DEPTH |init/uring

	; Process each file argument
	@args |skip 1 |map {
		$in |read-file-async
		?> {%"Error reading file ${filepath}: ${message}" |print-error}
	}
	
	; Ring cleanup handled automatically by Comp's scope management
}
